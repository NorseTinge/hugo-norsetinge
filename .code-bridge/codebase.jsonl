{"type":"struct","name":"NtfySender","file":"src/approval/ntfy.go","line":14,"endLine":16,"hash":"c88731afe21c6824","fields":["cfg"],"body":"type NtfySender struct {\n\tcfg *config.Config\n}","docstring":"NtfySender sends push notifications via ntfy.sh\n","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.847945909Z"}
{"type":"struct","name":"NtfyMessage","file":"src/approval/ntfy.go","line":19,"endLine":26,"hash":"e0cdca9530077793","fields":["Topic","Title","Message","Actions","Tags","Priority"],"body":"type NtfyMessage struct {\n\tTopic   string        `json:\"topic\"`\n\tTitle   string        `json:\"title\"`\n\tMessage string        `json:\"message\"`\n\tActions []NtfyAction  `json:\"actions,omitempty\"`\n\tTags    []string      `json:\"tags,omitempty\"`\n\tPriority int          `json:\"priority,omitempty\"`\n}","docstring":"NtfyMessage represents a ntfy notification\n","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.847958596Z"}
{"type":"struct","name":"NtfyAction","file":"src/approval/ntfy.go","line":29,"endLine":34,"hash":"a659df59516203be","fields":["Action","Label","URL","Clear"],"body":"type NtfyAction struct {\n\tAction string `json:\"action\"` // \"view\" or \"http\"\n\tLabel  string `json:\"label\"`\n\tURL    string `json:\"url\"`\n\tClear  bool   `json:\"clear,omitempty\"` // Clear notification after click\n}","docstring":"NtfyAction represents a clickable action button\n","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.847970144Z"}
{"type":"function","name":"NewNtfySender","file":"src/approval/ntfy.go","line":37,"endLine":39,"hash":"6398d29532ebe603","params":[{"name":"cfg","type":"*config.Config"}],"returns":"*NtfySender","body":"func NewNtfySender(cfg *config.Config) *NtfySender {\n\treturn \u0026NtfySender{cfg: cfg}\n}","docstring":"NewNtfySender creates a new ntfy sender\n","imports":["bytes","encoding/json","fmt","log","net/http","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.847977949Z"}
{"type":"function","name":"NtfySender.SendApprovalNotification","file":"src/approval/ntfy.go","line":42,"endLine":70,"hash":"c295c37af0f90529","params":[{"name":"title","type":"string"},{"name":"author","type":"string"},{"name":"previewURLPath","type":"string"},{"name":"articleID","type":"string"}],"returns":"error","body":"func (n *NtfySender) SendApprovalNotification(title, author, previewURLPath, articleID string) error {\n\tif !n.cfg.Ntfy.Enabled {\n\t\tlog.Printf(\"ntfy notifications disabled\")\n\t\treturn nil\n\t}\n\n\t// Generate Tailscale approval URL (https via tailscale serve)\n\t// This shows the approval page with 3 buttons + article preview\n\tapprovalURL := fmt.Sprintf(\"https://%s/approve/%s\",\n\t\tn.cfg.Approval.TailscaleHostname,\n\t\tarticleID)\n\n\tmsg := NtfyMessage{\n\t\tTopic:    n.cfg.Ntfy.Topic,\n\t\tTitle:    fmt.Sprintf(\"üì∞ %s\", title),\n\t\tMessage:  fmt.Sprintf(\"Af: %s\\n\\nKlik for at godkende/afvise\", author),\n\t\tPriority: 4, // High priority\n\t\tTags:     []string{\"newspaper\"},\n\t\tActions: []NtfyAction{\n\t\t\t{\n\t\t\t\tAction: \"view\",\n\t\t\t\tLabel:  \"Godkend artikel\",\n\t\t\t\tURL:    approvalURL,\n\t\t\t},\n\t\t},\n\t}\n\n\treturn n.send(msg)\n}","docstring":"SendApprovalNotification sends a simple notification with approval URL\n","imports":["bytes","encoding/json","fmt","log","net/http","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.847994483Z"}
{"type":"function","name":"NtfySender.send","file":"src/approval/ntfy.go","line":73,"endLine":108,"hash":"32a0d9c6d9a8fcac","params":[{"name":"msg","type":"NtfyMessage"}],"returns":"error","body":"func (n *NtfySender) send(msg NtfyMessage) error {\n\turl := fmt.Sprintf(\"%s/%s\", n.cfg.Ntfy.Server, n.cfg.Ntfy.Topic)\n\n\t// Send message as body, metadata as headers\n\treq, err := http.NewRequest(\"POST\", url, bytes.NewBufferString(msg.Message))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create request: %w\", err)\n\t}\n\n\t// Set headers according to ntfy documentation\n\treq.Header.Set(\"Title\", msg.Title)\n\treq.Header.Set(\"Priority\", fmt.Sprintf(\"%d\", msg.Priority))\n\treq.Header.Set(\"Tags\", \"newspaper\")\n\n\t// Add action button as JSON in header\n\tif len(msg.Actions) \u003e 0 {\n\t\tactionsJSON, _ := json.Marshal(msg.Actions)\n\t\treq.Header.Set(\"Actions\", string(actionsJSON))\n\t}\n\n\tlog.Printf(\"üì§ Sending ntfy notification: %s\", msg.Title)\n\n\tclient := \u0026http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to send ntfy notification: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"ntfy returned status %d\", resp.StatusCode)\n\t}\n\n\tlog.Printf(\"üì± ntfy notification sent: %s\", msg.Title)\n\treturn nil\n}","docstring":"send sends a ntfy notification using headers (not JSON body)\n","imports":["bytes","encoding/json","fmt","log","net/http","norsetinge/src/config"],"language":"go","indexedAt":"2025-10-03T16:18:26.848016487Z"}
{"type":"function","name":"NtfySender.ClearAllNotifications","file":"src/approval/ntfy.go","line":111,"endLine":136,"hash":"0ee3b27d44ab5fda","returns":"error","body":"func (n *NtfySender) ClearAllNotifications() error {\n\tif !n.cfg.Ntfy.Enabled {\n\t\treturn nil\n\t}\n\n\turl := fmt.Sprintf(\"%s/%s\", n.cfg.Ntfy.Server, n.cfg.Ntfy.Topic)\n\n\treq, err := http.NewRequest(\"DELETE\", url, nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create DELETE request: %w\", err)\n\t}\n\n\tclient := \u0026http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to clear ntfy notifications: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"ntfy DELETE returned status %d\", resp.StatusCode)\n\t}\n\n\tlog.Printf(\"üßπ Cleared all ntfy notifications from topic\")\n\treturn nil\n}","docstring":"ClearAllNotifications deletes all notifications from the topic\n","imports":["bytes","encoding/json","fmt","log","net/http","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.848040266Z"}
{"type":"struct","name":"Server","file":"src/approval/server.go","line":22,"endLine":30,"hash":"f0b8dcfe4ee1fc85","fields":["cfg","ntfySender","hugoBuilder","deployer","pendingArticles","mu","mover"],"body":"type Server struct {\n\tcfg             *config.Config\n\tntfySender      *NtfySender\n\thugoBuilder     *builder.HugoBuilder\n\tdeployer        *deployer.Deployer\n\tpendingArticles map[string]*PendingArticle\n\tmu              sync.RWMutex\n\tmover           FileMover\n}","docstring":"Server handles approval web requests\n","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.849957819Z"}
{"type":"interface","name":"FileMover","file":"src/approval/server.go","line":33,"endLine":35,"hash":"e217ce18bed9185d","methods":["MoveArticle"],"body":"type FileMover interface {\n\tMoveArticle(article *common.Article) error\n}","docstring":"FileMover interface for moving files based on status\n","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.849972801Z"}
{"type":"struct","name":"PendingArticle","file":"src/approval/server.go","line":38,"endLine":46,"hash":"ffd771511718d523","fields":["ID","Article","PreviewPath","Approved","Rejected","Comments","NotificationSent"],"body":"type PendingArticle struct {\n\tID               string\n\tArticle          *common.Article\n\tPreviewPath      string // Hugo preview HTML path (for iframe)\n\tApproved         bool\n\tRejected         bool\n\tComments         string\n\tNotificationSent bool   // To prevent re-sending notifications\n}","docstring":"PendingArticle represents an article awaiting approval\n","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.849984803Z"}
{"type":"function","name":"NewServer","file":"src/approval/server.go","line":49,"endLine":64,"hash":"c36244bf9f7c15e5","params":[{"name":"cfg","type":"*config.Config"}],"returns":"*Server","body":"func NewServer(cfg *config.Config) *Server {\n\ts := \u0026Server{\n\t\tcfg:             cfg,\n\t\tntfySender:      NewNtfySender(cfg),\n\t\thugoBuilder:     builder.NewHugoBuilder(cfg),\n\t\tdeployer:        deployer.NewDeployer(cfg),\n\t\tpendingArticles: make(map[string]*PendingArticle),\n\t}\n\n\t// Load pending articles from disk\n\tif err := s.loadPendingArticles(); err != nil {\n\t\tlog.Printf(\"Warning: Failed to load pending articles: %v\", err)\n\t}\n\n\treturn s\n}","docstring":"NewServer creates a new approval server\n","imports":["crypto/rand","encoding/hex","encoding/json","fmt","html/template","log","net/http","os","path/filepath","sync","norsetinge/src/builder","norsetinge/src/common","norsetinge/src/config","norsetinge/src/deployer"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.850001771Z"}
{"type":"function","name":"Server.SetMover","file":"src/approval/server.go","line":67,"endLine":69,"hash":"8b362efac628bf6c","params":[{"name":"mover","type":"FileMover"}],"body":"func (s *Server) SetMover(mover FileMover) {\n\ts.mover = mover\n}","docstring":"SetMover sets the file mover for handling file movements\n","imports":["crypto/rand","encoding/hex","encoding/json","fmt","html/template","log","net/http","os","path/filepath","sync","norsetinge/src/builder","norsetinge/src/common","norsetinge/src/config","norsetinge/src/deployer"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.850017018Z"}
{"type":"function","name":"Server.Start","file":"src/approval/server.go","line":72,"endLine":85,"hash":"0f0a27c53884b807","returns":"error","body":"func (s *Server) Start() error {\n\t// Serve Hugo public directory for previews\n\thttp.Handle(\"/preview/\", http.StripPrefix(\"/preview/\", http.FileServer(http.Dir(s.cfg.Hugo.PublicDir))))\n\n\thttp.HandleFunc(\"/approve/\", s.handleApproval)\n\thttp.HandleFunc(\"/action/approve/\", s.handleApprove)\n\thttp.HandleFunc(\"/action/approve-deploy/\", s.handleApproveAndDeploy)\n\thttp.HandleFunc(\"/action/reject/\", s.handleReject)\n\n\taddr := fmt.Sprintf(\"%s:%d\", s.cfg.Approval.Host, s.cfg.Approval.Port)\n\tlog.Printf(\"Approval server starting on %s\", addr)\n\n\treturn http.ListenAndServe(addr, nil)\n}","docstring":"Start starts the HTTP server\n","imports":["crypto/rand","encoding/hex","encoding/json","fmt","html/template","log","net/http","os","path/filepath","sync","norsetinge/src/builder","norsetinge/src/common","norsetinge/src/config","norsetinge/src/deployer"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.850032446Z"}
{"type":"function","name":"Server.RequestApproval","file":"src/approval/server.go","line":88,"endLine":138,"hash":"2cb881fed3219334","params":[{"name":"article","type":"*common.Article"}],"returns":"error","body":"func (s *Server) RequestApproval(article *common.Article) error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tid := article.ID\n\n\t// Check if a notification has already been sent for this article.\n\tif pending, exists := s.pendingArticles[id]; exists \u0026\u0026 pending.NotificationSent {\n\t\tlog.Printf(\"‚è≠Ô∏è Skipping notification, already pending for: %s\", article.Title)\n\t\treturn nil\n\t}\n\n\t// --- The rest of the operations happen inside the lock to ensure consistency ---\n\n\t// Build Hugo preview\n\tlog.Printf(\"Building Hugo preview for: %s\", article.Title)\n\thtmlPath, err := s.hugoBuilder.BuildPreview(article)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to build Hugo preview: %w\", err)\n\t}\n\n\t// Send ntfy push notification\n\tif s.cfg.Ntfy.Enabled {\n\t\tif err := s.ntfySender.SendApprovalNotification(\n\t\t\tarticle.Title,\n\t\t\tarticle.Author,\n\t\t\thtmlPath,\n\t\t\tid,\n\t\t); err != nil {\n\t\t\tlog.Printf(\"Warning: Failed to send ntfy notification: %v\", err)\n\t\t\t// Do not mark as sent if it fails, so it can be retried.\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Store pending article with preview path and mark notification as sent.\n\ts.pendingArticles[id] = \u0026PendingArticle{\n\t\tID:               id,\n\t\tArticle:          article,\n\t\tPreviewPath:      htmlPath,\n\t\tNotificationSent: true, // Mark as sent\n\t}\n\n\t// Persist to disk\n\tif err := s.savePendingArticles(); err != nil {\n\t\tlog.Printf(\"Warning: Failed to save pending articles: %v\", err)\n\t}\n\n\tlog.Printf(\"Approval request sent for: %s (ID: %s, Preview: %s)\", article.Title, id, htmlPath)\n\treturn nil\n}","docstring":"RequestApproval creates approval request and sends notification if not already sent.\n","imports":["crypto/rand","encoding/hex","encoding/json","fmt","html/template","log","net/http","os","path/filepath","sync","norsetinge/src/builder","norsetinge/src/common","norsetinge/src/config","norsetinge/src/deployer"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.850059436Z"}
{"type":"function","name":"Server.handleApproval","file":"src/approval/server.go","line":141,"endLine":155,"hash":"058f5facd825455c","params":[{"name":"w","type":"http.ResponseWriter"},{"name":"r","type":"*http.Request"}],"body":"func (s *Server) handleApproval(w http.ResponseWriter, r *http.Request) {\n\tid := r.URL.Path[len(\"/approve/\"):]\n\n\ts.mu.RLock()\n\tpending, exists := s.pendingArticles[id]\n\ts.mu.RUnlock()\n\n\tif !exists {\n\t\thttp.Error(w, \"Article not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\ttmpl := template.Must(template.New(\"approval\").Parse(approvalTemplate))\n\ttmpl.Execute(w, pending)\n}","docstring":"handleApproval shows the approval page\n","imports":["crypto/rand","encoding/hex","encoding/json","fmt","html/template","log","net/http","os","path/filepath","sync","norsetinge/src/builder","norsetinge/src/common","norsetinge/src/config","norsetinge/src/deployer"],"language":"go","indexedAt":"2025-10-03T16:18:26.850078485Z"}
{"type":"function","name":"Server.handleApprove","file":"src/approval/server.go","line":158,"endLine":218,"hash":"44ebc748feeec780","params":[{"name":"w","type":"http.ResponseWriter"},{"name":"r","type":"*http.Request"}],"body":"func (s *Server) handleApprove(w http.ResponseWriter, r *http.Request) {\n\tid := r.URL.Path[len(\"/action/approve/\"):]\n\tlog.Printf(\"üîµ handleApprove called for ID: %s\", id)\n\n\tlog.Printf(\"üîµ Attempting to lock...\")\n\ts.mu.Lock()\n\tlog.Printf(\"üîµ Lock acquired\")\n\tpending, exists := s.pendingArticles[id]\n\tif !exists {\n\t\ts.mu.Unlock()\n\t\tlog.Printf(\"üî¥ Article not found: %s\", id)\n\t\thttp.Error(w, \"Article not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tdelete(s.pendingArticles, id)\n\ts.mu.Unlock()\n\tlog.Printf(\"üîµ Lock released\")\n\n\t// Persist the change to the pending articles list on disk\n\tlog.Printf(\"üîµ Saving pending articles...\")\n\tif err := s.savePendingArticles(); err != nil {\n\t\tlog.Printf(\"Warning: Failed to save pending articles list: %v\", err)\n\t}\n\n\tlog.Printf(\"Article approved: %s - moving to udgivet/\", pending.Article.Title)\n\n\t// Move article to udgivet/\n\tpending.Article.UpdateStatus(\"published\")\n\tif err := pending.Article.WriteFrontmatter(); err != nil {\n\t\tlog.Printf(\"Error updating article status: %v\", err)\n\t\thttp.Error(w, \"Failed to update article\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif s.mover != nil {\n\t\tif err := s.mover.MoveArticle(pending.Article); err != nil {\n\t\t\tlog.Printf(\"Error moving article: %v\", err)\n\t\t} else {\n\t\t\tlog.Printf(\"‚úì Article moved to udgivet/: %s\", pending.Article.Title)\n\t\t}\n\t}\n\n\t// Clean up preview files\n\ts.cleanupPreviewFiles(pending.Article)\n\n\t// Clear ntfy notification for this approval\n\tif s.cfg.Ntfy.Enabled {\n\t\tif err := s.ntfySender.ClearAllNotifications(); err != nil {\n\t\t\tlog.Printf(\"Warning: Failed to clear ntfy notifications: %v\", err)\n\t\t}\n\t}\n\n\tfmt.Fprintf(w, `\n\t\t\u003c!DOCTYPE html\u003e\n\t\t\u003chtml\u003e\u003chead\u003e\u003cmeta charset=\"UTF-8\"\u003e\u003ctitle\u003eGodkendt\u003c/title\u003e\u003c/head\u003e\n\t\t\u003cbody style=\"font-family: sans-serif; max-width: 600px; margin: 50px auto; text-align: center;\"\u003e\n\t\t\t\u003ch1\u003e‚úÖ Artikel Godkendt!\u003c/h1\u003e\n\t\t\t\u003cp\u003eArtiklen er flyttet til udgivet/ og vil blive deployeret ved n√¶ste automatiske build (hver 10-15 min).\u003c/p\u003e\n\t\t\u003c/body\u003e\u003c/html\u003e\n\t`)\n}","docstring":"handleApprove handles normal approval (no immediate deploy)\n","imports":["crypto/rand","encoding/hex","encoding/json","fmt","html/template","log","net/http","os","path/filepath","sync","norsetinge/src/builder","norsetinge/src/common","norsetinge/src/config","norsetinge/src/deployer"],"language":"go","indexedAt":"2025-10-03T16:18:26.850106052Z"}
{"type":"function","name":"Server.handleApproveAndDeploy","file":"src/approval/server.go","line":221,"endLine":291,"hash":"50027766fb2048d5","params":[{"name":"w","type":"http.ResponseWriter"},{"name":"r","type":"*http.Request"}],"body":"func (s *Server) handleApproveAndDeploy(w http.ResponseWriter, r *http.Request) {\n\tid := r.URL.Path[len(\"/action/approve-deploy/\"):]\n\n\ts.mu.Lock()\n\tpending, exists := s.pendingArticles[id]\n\tif !exists {\n\t\ts.mu.Unlock()\n\t\thttp.Error(w, \"Article not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tdelete(s.pendingArticles, id)\n\ts.mu.Unlock()\n\n\t// Persist the change to the pending articles list on disk\n\tif err := s.savePendingArticles(); err != nil {\n\t\tlog.Printf(\"Warning: Failed to save pending articles list: %v\", err)\n\t}\n\n\tlog.Printf(\"Article approved with immediate deploy: %s\", pending.Article.Title)\n\n\t// 1. Move article to udgivet/\n\tpending.Article.UpdateStatus(\"published\")\n\tif err := pending.Article.WriteFrontmatter(); err != nil {\n\t\tlog.Printf(\"Error updating article status: %v\", err)\n\t\thttp.Error(w, \"Failed to update article\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif s.mover != nil {\n\t\tif err := s.mover.MoveArticle(pending.Article); err != nil {\n\t\t\tlog.Printf(\"Error moving article: %v\", err)\n\t\t} else {\n\t\t\tlog.Printf(\"‚úì Article moved to udgivet/: %s\", pending.Article.Title)\n\t\t}\n\t}\n\n\t// Clean up preview files\n\ts.cleanupPreviewFiles(pending.Article)\n\n\t// Clear ntfy notification for this approval\n\tif s.cfg.Ntfy.Enabled {\n\t\tif err := s.ntfySender.ClearAllNotifications(); err != nil {\n\t\t\tlog.Printf(\"Warning: Failed to clear ntfy notifications: %v\", err)\n\t\t}\n\t}\n\n\t// 2. Build full Hugo site\n\tpublicDir, mirrorDir, err := s.hugoBuilder.BuildFullSite()\n\tif err != nil {\n\t\tlog.Printf(\"Error building site: %v\", err)\n\t\thttp.Error(w, \"Failed to build site\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// 3. Deploy (mirror-sync + git + rsync)\n\tif err := s.deployer.Deploy(publicDir, mirrorDir); err != nil {\n\t\tlog.Printf(\"Error deploying: %v\", err)\n\t\thttp.Error(w, \"Failed to deploy site\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tfmt.Fprintf(w, `\n\t\t\u003c!DOCTYPE html\u003e\n\t\t\u003chtml\u003e\u003chead\u003e\u003cmeta charset=\"UTF-8\"\u003e\u003ctitle\u003eDeployeret\u003c/title\u003e\u003c/head\u003e\n\t\t\u003cbody style=\"font-family: sans-serif; max-width: 600px; margin: 50px auto; text-align: center;\"\u003e\n\t\t\t\u003ch1\u003e‚ö° Artikel Godkendt \u0026 Deployeret!\u003c/h1\u003e\n\t\t\t\u003cp\u003eArtiklen er nu live p√• norsetinge.com\u003c/p\u003e\n\t\t\t\u003cp style=\"color: #666; font-size: 14px;\"\u003eBygget, deployeret og arkiveret i udgivet/\u003c/p\u003e\n\t\t\u003c/body\u003e\u003c/html\u003e\n\t`)\n}","docstring":"handleApproveAndDeploy handles immediate approval + deploy\n","imports":["crypto/rand","encoding/hex","encoding/json","fmt","html/template","log","net/http","os","path/filepath","sync","norsetinge/src/builder","norsetinge/src/common","norsetinge/src/config","norsetinge/src/deployer"],"language":"go","indexedAt":"2025-10-03T16:18:26.850136551Z"}
{"type":"function","name":"Server.handleReject","file":"src/approval/server.go","line":294,"endLine":347,"hash":"c3774c923e21b14c","params":[{"name":"w","type":"http.ResponseWriter"},{"name":"r","type":"*http.Request"}],"body":"func (s *Server) handleReject(w http.ResponseWriter, r *http.Request) {\n\tid := r.URL.Path[len(\"/action/reject/\"):]\n\n\ts.mu.Lock()\n\tpending, exists := s.pendingArticles[id]\n\tif !exists {\n\t\ts.mu.Unlock()\n\t\thttp.Error(w, \"Article not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tdelete(s.pendingArticles, id)\n\ts.mu.Unlock()\n\n\t// Persist the change to the pending articles list on disk\n\tif err := s.savePendingArticles(); err != nil {\n\t\tlog.Printf(\"Warning: Failed to save pending articles list: %v\", err)\n\t}\n\n\t// Update article status to rejected and move file\n\tpending.Article.UpdateStatus(\"rejected\")\n\tif err := pending.Article.WriteFrontmatter(); err != nil {\n\t\tlog.Printf(\"Error updating article status: %v\", err)\n\t\thttp.Error(w, \"Failed to update article\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Move file to afvist/\n\tif s.mover != nil {\n\t\tif err := s.mover.MoveArticle(pending.Article); err != nil {\n\t\t\tlog.Printf(\"Error moving article: %v\", err)\n\t\t}\n\t}\n\n\tlog.Printf(\"Article rejected: %s\", pending.Article.Title)\n\n\t// Clean up preview files\n\ts.cleanupPreviewFiles(pending.Article)\n\n\t// Clear ntfy notification for this rejection\n\tif s.cfg.Ntfy.Enabled {\n\t\tif err := s.ntfySender.ClearAllNotifications(); err != nil {\n\t\t\tlog.Printf(\"Warning: Failed to clear ntfy notifications: %v\", err)\n\t\t}\n\t}\n\n\tfmt.Fprintf(w, `\n\t\t\u003c!DOCTYPE html\u003e\n\t\t\u003chtml\u003e\u003chead\u003e\u003cmeta charset=\"UTF-8\"\u003e\u003ctitle\u003eAfvist\u003c/title\u003e\u003c/head\u003e\n\t\t\u003cbody style=\"font-family: sans-serif; max-width: 600px; margin: 50px auto; text-align: center;\"\u003e\n\t\t\t\u003ch1\u003e‚ùå Artikel Afvist\u003c/h1\u003e\n\t\t\t\u003cp\u003eArtiklen er flyttet til afvist/ mappen.\u003c/p\u003e\n\t\t\u003c/body\u003e\u003c/html\u003e\n\t`)\n}","docstring":"handleReject handles rejection action\n","imports":["crypto/rand","encoding/hex","encoding/json","fmt","html/template","log","net/http","os","path/filepath","sync","norsetinge/src/builder","norsetinge/src/common","norsetinge/src/config","norsetinge/src/deployer"],"language":"go","indexedAt":"2025-10-03T16:18:26.850160981Z"}
{"type":"function","name":"generateID","file":"src/approval/server.go","line":350,"endLine":356,"hash":"7e38616a6deac273","returns":"(string, error)","body":"func generateID() (string, error) {\n\tbytes := make([]byte, 16)\n\tif _, err := rand.Read(bytes); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn hex.EncodeToString(bytes), nil\n}","docstring":"generateID generates a random ID\n","imports":["crypto/rand","encoding/hex","encoding/json","fmt","html/template","log","net/http","os","path/filepath","sync","norsetinge/src/builder","norsetinge/src/common","norsetinge/src/config","norsetinge/src/deployer"],"language":"go","indexedAt":"2025-10-03T16:18:26.850180482Z"}
{"type":"function","name":"Server.getPendingArticlesPath","file":"src/approval/server.go","line":359,"endLine":361,"hash":"8444ef7cd0979bf6","returns":"string","body":"func (s *Server) getPendingArticlesPath() string {\n\treturn filepath.Join(s.cfg.Dropbox.BasePath, \".pending_approvals.json\")\n}","docstring":"getPendingArticlesPath returns the path to pending articles storage file\n","imports":["crypto/rand","encoding/hex","encoding/json","fmt","html/template","log","net/http","os","path/filepath","sync","norsetinge/src/builder","norsetinge/src/common","norsetinge/src/config","norsetinge/src/deployer"],"language":"go","indexedAt":"2025-10-03T16:18:26.850196885Z"}
{"type":"function","name":"Server.savePendingArticles","file":"src/approval/server.go","line":364,"endLine":380,"hash":"f1702b6ce044cb36","returns":"error","body":"func (s *Server) savePendingArticles() error {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\n\tdata, err := json.MarshalIndent(s.pendingArticles, \"\", \"  \")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal pending articles: %w\", err)\n\t}\n\n\tpath := s.getPendingArticlesPath()\n\tif err := os.WriteFile(path, data, 0644); err != nil {\n\t\treturn fmt.Errorf(\"failed to write pending articles file: %w\", err)\n\t}\n\n\tlog.Printf(\"Saved %d pending articles to %s\", len(s.pendingArticles), path)\n\treturn nil\n}","docstring":"savePendingArticles persists pending articles to disk\n","imports":["crypto/rand","encoding/hex","encoding/json","fmt","html/template","log","net/http","os","path/filepath","sync","norsetinge/src/builder","norsetinge/src/common","norsetinge/src/config","norsetinge/src/deployer"],"language":"go","indexedAt":"2025-10-03T16:18:26.850211319Z"}
{"type":"function","name":"Server.cleanupPreviewFiles","file":"src/approval/server.go","line":383,"endLine":408,"hash":"3b51ca79557576d2","params":[{"name":"article","type":"*common.Article"}],"body":"func (s *Server) cleanupPreviewFiles(article *common.Article) {\n\tslug := article.GetSlug()\n\tpreviewDirName := fmt.Sprintf(\"preview-%s\", slug)\n\n\t// Clean up from public directory\n\tpublicPreviewPath := filepath.Join(s.cfg.Hugo.PublicDir, previewDirName)\n\tif err := os.RemoveAll(publicPreviewPath); err != nil \u0026\u0026 !os.IsNotExist(err) {\n\t\tlog.Printf(\"Warning: Failed to remove preview from public: %v\", err)\n\t} else if err == nil {\n\t\tlog.Printf(\"üßπ Cleaned up preview from public/: %s\", previewDirName)\n\t}\n\n\t// Clean up from mirror directory\n\tmirrorPreviewPath := filepath.Join(s.cfg.Hugo.MirrorDir, previewDirName)\n\tif err := os.RemoveAll(mirrorPreviewPath); err != nil \u0026\u0026 !os.IsNotExist(err) {\n\t\tlog.Printf(\"Warning: Failed to remove preview from mirror: %v\", err)\n\t} else if err == nil {\n\t\tlog.Printf(\"üßπ Cleaned up preview from mirror/: %s\", previewDirName)\n\t}\n\n\t// Also clean up the temporary content file if it still exists\n\tcontentPath := filepath.Join(s.cfg.Hugo.SiteDir, \"content\", fmt.Sprintf(\"preview-%s.md\", slug))\n\tif err := os.Remove(contentPath); err != nil \u0026\u0026 !os.IsNotExist(err) {\n\t\tlog.Printf(\"Warning: Failed to remove preview content: %v\", err)\n\t}\n}","docstring":"cleanupPreviewFiles removes preview files from public and mirror directories\n","imports":["crypto/rand","encoding/hex","encoding/json","fmt","html/template","log","net/http","os","path/filepath","sync","norsetinge/src/builder","norsetinge/src/common","norsetinge/src/config","norsetinge/src/deployer"],"language":"go","indexedAt":"2025-10-03T16:18:26.850229732Z"}
{"type":"function","name":"Server.loadPendingArticles","file":"src/approval/server.go","line":411,"endLine":432,"hash":"b33b39b0db5344e9","returns":"error","body":"func (s *Server) loadPendingArticles() error {\n\tpath := s.getPendingArticlesPath()\n\n\tdata, err := os.ReadFile(path)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\t// File doesn't exist yet, not an error\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"failed to read pending articles file: %w\", err)\n\t}\n\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tif err := json.Unmarshal(data, \u0026s.pendingArticles); err != nil {\n\t\treturn fmt.Errorf(\"failed to unmarshal pending articles: %w\", err)\n\t}\n\n\tlog.Printf(\"Loaded %d pending articles from %s\", len(s.pendingArticles), path)\n\treturn nil\n}","docstring":"loadPendingArticles loads pending articles from disk\n","imports":["crypto/rand","encoding/hex","encoding/json","fmt","html/template","log","net/http","os","path/filepath","sync","norsetinge/src/builder","norsetinge/src/common","norsetinge/src/config","norsetinge/src/deployer"],"language":"go","indexedAt":"2025-10-03T16:18:26.85025003Z"}
{"type":"function","name":"TestNewServer","file":"src/approval/server_test.go","line":12,"endLine":33,"hash":"d67ea25ea271ab0e","params":[{"name":"t","type":"*testing.T"}],"body":"func TestNewServer(t *testing.T) {\n\tcfg := \u0026config.Config{\n\t\tApproval: config.ApprovalConfig{\n\t\t\tHost: \"0.0.0.0\",\n\t\t\tPort: 8080,\n\t\t\tTailscaleHostname: \"norsetinge.tailnet.ts.net\",\n\t\t},\n\t}\n\n\tserver := NewServer(cfg)\n\tif server == nil {\n\t\tt.Fatal(\"NewServer returned nil\")\n\t}\n\n\tif server.cfg != cfg {\n\t\tt.Error(\"Config not set correctly\")\n\t}\n\n\tif server.pendingArticles == nil {\n\t\tt.Error(\"pendingArticles map not initialized\")\n\t}\n}","imports":["os","path/filepath","testing","norsetinge/src/common","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.850835309Z"}
{"type":"function","name":"TestGenerateID","file":"src/approval/server_test.go","line":35,"endLine":54,"hash":"4b49e8c860b48818","params":[{"name":"t","type":"*testing.T"}],"body":"func TestGenerateID(t *testing.T) {\n\tid1, err := generateID()\n\tif err != nil {\n\t\tt.Fatalf(\"generateID failed: %v\", err)\n\t}\n\n\tif len(id1) != 32 { // 16 bytes = 32 hex chars\n\t\tt.Errorf(\"Expected ID length 32, got %d\", len(id1))\n\t}\n\n\t// Generate another ID to ensure uniqueness\n\tid2, err := generateID()\n\tif err != nil {\n\t\tt.Fatalf(\"generateID failed: %v\", err)\n\t}\n\n\tif id1 == id2 {\n\t\tt.Error(\"Generated IDs should be unique\")\n\t}\n}","imports":["os","path/filepath","testing","norsetinge/src/common","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.850845159Z"}
{"type":"function","name":"TestRequestApproval","file":"src/approval/server_test.go","line":56,"endLine":100,"hash":"c033b6abda139bfb","params":[{"name":"t","type":"*testing.T"}],"body":"func TestRequestApproval(t *testing.T) {\n\ttmpDir := t.TempDir()\n\n\tcfg := \u0026config.Config{\n\t\tApproval: config.ApprovalConfig{\n\t\t\tHost: \"0.0.0.0\",\n\t\t\tPort: 8080,\n\t\t\tTailscaleHostname: \"norsetinge.tailnet.ts.net\",\n\t\t},\n\t\tHugo: config.HugoConfig{\n\t\t\tSiteDir:   tmpDir + \"/site\",\n\t\t\tPublicDir: tmpDir + \"/public\",\n\t\t\tMirrorDir: tmpDir + \"/mirror\",\n\t\t},\n\t\tNtfy: config.NtfyConfig{\n\t\t\tEnabled: false, // Disable ntfy for tests\n\t\t},\n\t\tDropbox: config.DropboxConfig{\n\t\t\tBasePath: tmpDir,\n\t\t},\n\t}\n\n\tserver := NewServer(cfg)\n\n\tarticle := \u0026common.Article{\n\t\tID:      \"#TEST01\",\n\t\tTitle:   \"Test Article\",\n\t\tAuthor:  \"TB\",\n\t\tContent: \"Test content\",\n\t}\n\n\t// Note: Hugo build will fail without valid Hugo setup, but that's expected\n\t// The test should check that the function attempts to add the article\n\terr := server.RequestApproval(article)\n\n\t// We expect an error because Hugo isn't set up, but that's okay for this test\n\t// The important thing is that if ntfy is disabled, it shouldn't fail on that\n\tif err != nil {\n\t\t// Expected - Hugo build will fail\n\t\tt.Logf(\"RequestApproval returned expected error: %v\", err)\n\t}\n\n\t// Even with error, check if notification was attempted\n\t// (This test mainly validates that the function doesn't panic)\n}","imports":["os","path/filepath","testing","norsetinge/src/common","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.850856241Z"}
{"type":"function","name":"TestCleanupPreviewFiles","file":"src/approval/server_test.go","line":103,"endLine":173,"hash":"3d3543c2e3fbd4c1","params":[{"name":"t","type":"*testing.T"}],"body":"func TestCleanupPreviewFiles(t *testing.T) {\n\ttmpDir := t.TempDir()\n\n\tcfg := \u0026config.Config{\n\t\tHugo: config.HugoConfig{\n\t\t\tSiteDir:   filepath.Join(tmpDir, \"site\"),\n\t\t\tPublicDir: filepath.Join(tmpDir, \"public\"),\n\t\t\tMirrorDir: filepath.Join(tmpDir, \"mirror\"),\n\t\t},\n\t\tDropbox: config.DropboxConfig{\n\t\t\tBasePath: tmpDir,\n\t\t},\n\t}\n\n\t// Create directories\n\tos.MkdirAll(cfg.Hugo.SiteDir+\"/content\", 0755)\n\tos.MkdirAll(cfg.Hugo.PublicDir, 0755)\n\tos.MkdirAll(cfg.Hugo.MirrorDir, 0755)\n\n\tserver := NewServer(cfg)\n\n\tarticle := \u0026common.Article{\n\t\tID:      \"#TEST99\",\n\t\tTitle:   \"Test Article for Cleanup\",\n\t\tAuthor:  \"TB\",\n\t\tContent: \"Test content\",\n\t}\n\n\tslug := article.GetSlug()\n\tpreviewDirName := \"preview-\" + slug\n\n\t// Create fake preview files in all three locations\n\tpublicPreviewPath := filepath.Join(cfg.Hugo.PublicDir, previewDirName)\n\tmirrorPreviewPath := filepath.Join(cfg.Hugo.MirrorDir, previewDirName)\n\tcontentPreviewPath := filepath.Join(cfg.Hugo.SiteDir, \"content\", \"preview-\"+slug+\".md\")\n\n\tos.MkdirAll(publicPreviewPath, 0755)\n\tos.MkdirAll(mirrorPreviewPath, 0755)\n\tos.WriteFile(contentPreviewPath, []byte(\"test content\"), 0644)\n\n\t// Create dummy files inside preview dirs\n\tos.WriteFile(filepath.Join(publicPreviewPath, \"index.html\"), []byte(\"test\"), 0644)\n\tos.WriteFile(filepath.Join(mirrorPreviewPath, \"index.html\"), []byte(\"test\"), 0644)\n\n\t// Verify files exist before cleanup\n\tif _, err := os.Stat(publicPreviewPath); os.IsNotExist(err) {\n\t\tt.Fatal(\"Public preview path should exist before cleanup\")\n\t}\n\tif _, err := os.Stat(mirrorPreviewPath); os.IsNotExist(err) {\n\t\tt.Fatal(\"Mirror preview path should exist before cleanup\")\n\t}\n\tif _, err := os.Stat(contentPreviewPath); os.IsNotExist(err) {\n\t\tt.Fatal(\"Content preview file should exist before cleanup\")\n\t}\n\n\t// Run cleanup\n\tserver.cleanupPreviewFiles(article)\n\n\t// Verify files are removed after cleanup\n\tif _, err := os.Stat(publicPreviewPath); !os.IsNotExist(err) {\n\t\tt.Error(\"Public preview path should be removed after cleanup\")\n\t}\n\tif _, err := os.Stat(mirrorPreviewPath); !os.IsNotExist(err) {\n\t\tt.Error(\"Mirror preview path should be removed after cleanup\")\n\t}\n\tif _, err := os.Stat(contentPreviewPath); !os.IsNotExist(err) {\n\t\tt.Error(\"Content preview file should be removed after cleanup\")\n\t}\n\n\tt.Log(\"‚úÖ Bug 9 fix verified: Preview files cleaned up successfully\")\n}","docstring":"TestCleanupPreviewFiles tests Bug 9 fix: preview cleanup functionality\n","imports":["os","path/filepath","testing","norsetinge/src/common","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.850872779Z"}
{"type":"function","name":"main","file":"src/cmd/test_approval/main.go","line":13,"endLine":48,"hash":"e6e0984a09e160fe","body":"func main() {\n\tif len(os.Args) \u003c 2 {\n\t\tfmt.Println(\"Usage: go run test_approval.go \u003carticle-file\u003e\")\n\t\tos.Exit(1)\n\t}\n\n\tarticlePath := os.Args[1]\n\n\t// Load config\n\tcfg, err := config.Load(\"../../../config.yaml\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to load config: %v\", err)\n\t}\n\n\t// Parse article\n\tarticle, err := common.ParseArticle(articlePath)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to parse article: %v\", err)\n\t}\n\n\tfmt.Printf(\"Article: %s by %s\\n\", article.Title, article.Author)\n\tfmt.Printf(\"Status: publish=%d\\n\", article.Status.Publish)\n\n\t// Create approval server\n\tserver := approval.NewServer(cfg)\n\n\t// Trigger approval\n\tfmt.Println(\"\\nTriggering approval process...\")\n\tif err := server.RequestApproval(article); err != nil {\n\t\tlog.Fatalf(\"Approval failed: %v\", err)\n\t}\n\n\tfmt.Println(\"‚úÖ Approval request sent successfully!\")\n\tfmt.Printf(\"Check your email at: %s\\n\", cfg.Email.ApprovalRecipient)\n\tfmt.Printf(\"Preview location: %s/godkendelse/%s/\\n\", filepath.Dir(cfg.Dropbox.BasePath), article.GetSlug())\n}","imports":["fmt","log","norsetinge/src/approval","norsetinge/src/common","norsetinge/src/config","os","path/filepath"],"language":"go","indexedAt":"2025-10-03T16:18:26.853317611Z"}
{"type":"struct","name":"Article","file":"src/common/frontmatter.go","line":17,"endLine":49,"hash":"611142144993ed0e","fields":["FilePath","ID","Title","Author","Status","Description","Images","Tags","Videos","Audio","Slug","Categories","Series","Favicon","AppIcon","Language","Content"],"body":"type Article struct {\n\tFilePath string `yaml:\"-\"` // Internal use only - do not read from YAML\n\n\t// Unique identifier (auto-generated, persistent)\n\tID string `yaml:\"id\"`\n\n\t// Required fields\n\tTitle  string `yaml:\"title\"`\n\tAuthor string `yaml:\"author\"`\n\tStatus Status `yaml:\"status\"`\n\n\t// Optional SEO fields\n\tDescription string   `yaml:\"description,omitempty\"`\n\tImages      []string `yaml:\"images,omitempty\"`\n\tTags        []string `yaml:\"tags,omitempty\"`\n\tVideos      []string `yaml:\"videos,omitempty\"`\n\tAudio       []string `yaml:\"audio,omitempty\"`\n\n\t// Optional organization fields\n\tSlug       string   `yaml:\"slug,omitempty\"`\n\tCategories []string `yaml:\"categories,omitempty\"`\n\tSeries     string   `yaml:\"series,omitempty\"`\n\n\t// Optional branding fields\n\tFavicon string `yaml:\"favicon,omitempty\"`\n\tAppIcon string `yaml:\"app_icon,omitempty\"`\n\n\t// Optional language field (ISO 639-1 code, e.g., \"da\", \"en\", \"de\")\n\tLanguage string `yaml:\"language,omitempty\"`\n\n\t// Raw content (after frontmatter)\n\tContent string\n}","docstring":"Article represents a parsed markdown article with frontmatter\n","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.853863499Z"}
{"type":"struct","name":"Status","file":"src/common/frontmatter.go","line":52,"endLine":59,"hash":"ea8584166d387e13","fields":["Draft","Revision","Publish","Published","Rejected","Update"],"body":"type Status struct {\n\tDraft     int `yaml:\"draft\"`\n\tRevision  int `yaml:\"revision\"`\n\tPublish   int `yaml:\"publish\"`\n\tPublished int `yaml:\"published\"`\n\tRejected  int `yaml:\"rejected\"`\n\tUpdate    int `yaml:\"update\"`\n}","docstring":"Status represents the article workflow status\n","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.853876134Z"}
{"type":"function","name":"ParseArticle","file":"src/common/frontmatter.go","line":62,"endLine":102,"hash":"f9e26a3fc81fbd7b","params":[{"name":"filePath","type":"string"}],"returns":"(*Article, error)","body":"func ParseArticle(filePath string) (*Article, error) {\n\tdata, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read file: %w\", err)\n\t}\n\n\t// Split frontmatter and content\n\tparts := bytes.SplitN(data, []byte(\"---\"), 3)\n\tif len(parts) \u003c 3 {\n\t\treturn nil, fmt.Errorf(\"invalid frontmatter: missing --- delimiters\")\n\t}\n\n\t// Parse YAML frontmatter\n\tarticle := \u0026Article{\n\t\tFilePath: filePath,\n\t\tContent:  string(bytes.TrimSpace(parts[2])),\n\t}\n\n\tif err := yaml.Unmarshal(parts[1], article); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse frontmatter: %w\", err)\n\t}\n\n\t// Validate required fields\n\tif article.Title == \"\" {\n\t\treturn nil, fmt.Errorf(\"missing required field: title\")\n\t}\n\tif article.Author == \"\" {\n\t\treturn nil, fmt.Errorf(\"missing required field: author\")\n\t}\n\n\t// Generate ID if missing\n\tif article.ID == \"\" {\n\t\tarticle.ID = article.generateID()\n\t\t// Save ID to frontmatter\n\t\tif err := article.WriteFrontmatter(); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to save generated ID: %w\", err)\n\t\t}\n\t}\n\n\treturn article, nil\n}","docstring":"ParseArticle reads a markdown file and parses the YAML frontmatter\n","imports":["bytes","crypto/sha256","encoding/hex","fmt","os","regexp","strings","time","gopkg.in/yaml.v3"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.853896585Z"}
{"type":"function","name":"Article.GetCurrentStatus","file":"src/common/frontmatter.go","line":105,"endLine":126,"hash":"8331a6d0feef802e","returns":"string","body":"func (a *Article) GetCurrentStatus() string {\n\tstatuses := []struct {\n\t\tname  string\n\t\tvalue int\n\t}{\n\t\t{\"draft\", a.Status.Draft},\n\t\t{\"revision\", a.Status.Revision},\n\t\t{\"publish\", a.Status.Publish},\n\t\t{\"published\", a.Status.Published},\n\t\t{\"rejected\", a.Status.Rejected},\n\t\t{\"update\", a.Status.Update},\n\t}\n\n\tcurrentStatus := \"unknown\"\n\tfor _, s := range statuses {\n\t\tif s.value == 1 {\n\t\t\tcurrentStatus = s.name\n\t\t}\n\t}\n\n\treturn currentStatus\n}","docstring":"GetCurrentStatus returns the current status based on \"last 1 wins\" rule\n","imports":["bytes","crypto/sha256","encoding/hex","fmt","os","regexp","strings","time","gopkg.in/yaml.v3"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.853916449Z"}
{"type":"function","name":"Article.GetSlug","file":"src/common/frontmatter.go","line":129,"endLine":138,"hash":"1226048331a15b70","returns":"string","body":"func (a *Article) GetSlug() string {\n\tslug := strings.ToLower(a.Title)\n\tslug = strings.ReplaceAll(slug, \" \", \"-\")\n\tslug = strings.ReplaceAll(slug, \"√¶\", \"ae\")\n\tslug = strings.ReplaceAll(slug, \"√∏\", \"oe\")\n\tslug = strings.ReplaceAll(slug, \"√•\", \"aa\")\n\t// Remove non-alphanumeric characters except hyphens\n\tslug = regexp.MustCompile(`[^a-z0-9-]+`).ReplaceAllString(slug, \"\")\n\treturn slug\n}","docstring":"GetSlug returns a URL-friendly slug from the title\n","imports":["bytes","crypto/sha256","encoding/hex","fmt","os","regexp","strings","time","gopkg.in/yaml.v3"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.853929056Z"}
{"type":"function","name":"Article.UpdateStatus","file":"src/common/frontmatter.go","line":141,"endLine":168,"hash":"1ce2abd7b5e0cdff","params":[{"name":"newStatus","type":"string"}],"returns":"error","body":"func (a *Article) UpdateStatus(newStatus string) error {\n\t// Reset all status flags first\n\ta.Status.Draft = 0\n\ta.Status.Revision = 0\n\ta.Status.Publish = 0\n\ta.Status.Published = 0\n\ta.Status.Rejected = 0\n\ta.Status.Update = 0\n\n\t// Set the new status\n\tswitch newStatus {\n\tcase \"draft\":\n\t\ta.Status.Draft = 1\n\tcase \"revision\":\n\t\ta.Status.Revision = 1\n\tcase \"publish\":\n\t\ta.Status.Publish = 1\n\tcase \"published\":\n\t\ta.Status.Published = 1\n\tcase \"rejected\":\n\t\ta.Status.Rejected = 1\n\tcase \"update\":\n\t\ta.Status.Update = 1\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid status: %s\", newStatus)\n\t}\n\treturn nil\n}","docstring":"UpdateStatus sets a new status and clears all other status flags\n","imports":["bytes","crypto/sha256","encoding/hex","fmt","os","regexp","strings","time","gopkg.in/yaml.v3"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.853947993Z"}
{"type":"function","name":"Article.WriteFrontmatter","file":"src/common/frontmatter.go","line":171,"endLine":184,"hash":"495117b22284f46c","returns":"error","body":"func (a *Article) WriteFrontmatter() error {\n\tfrontmatter, err := yaml.Marshal(a)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal frontmatter: %w\", err)\n\t}\n\n\tnewContent := fmt.Sprintf(\"---\\n%s---\\n\\n%s\", string(frontmatter), a.Content)\n\n\tif err := os.WriteFile(a.FilePath, []byte(newContent), 0644); err != nil {\n\t\treturn fmt.Errorf(\"failed to write file: %w\", err)\n\t}\n\n\treturn nil\n}","docstring":"WriteFrontmatter updates the file with modified frontmatter\n","imports":["bytes","crypto/sha256","encoding/hex","fmt","os","regexp","strings","time","gopkg.in/yaml.v3"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.853962589Z"}
{"type":"function","name":"Article.generateID","file":"src/common/frontmatter.go","line":188,"endLine":196,"hash":"1a44435f6b1fc79a","returns":"string","body":"func (a *Article) generateID() string {\n\t// Combine title, author, and current timestamp for uniqueness\n\tdata := fmt.Sprintf(\"%s|%s|%d\", a.Title, a.Author, time.Now().UnixNano())\n\thash := sha256.Sum256([]byte(data))\n\n\t// Convert to uppercase hex and take first 6 characters\n\thexStr := strings.ToUpper(hex.EncodeToString(hash[:]))\n\treturn \"#\" + hexStr[:6]\n}","docstring":"generateID creates a unique ID based on title, author, and timestamp\nFormat: #ABC123 (6 characters: 3 letters + 3 numbers/letters, always uppercase)\n","imports":["bytes","crypto/sha256","encoding/hex","fmt","os","regexp","strings","time","gopkg.in/yaml.v3"],"language":"go","indexedAt":"2025-10-03T16:18:26.853982465Z"}
{"type":"function","name":"TestParseArticle","file":"src/common/frontmatter_test.go","line":9,"endLine":65,"hash":"607a80a6f1d66fb6","params":[{"name":"t","type":"*testing.T"}],"body":"func TestParseArticle(t *testing.T) {\n\t// Create temp test file\n\ttmpDir := t.TempDir()\n\ttestFile := filepath.Join(tmpDir, \"test.md\")\n\n\tcontent := `---\ntitle: \"Test Article\"\nauthor: \"TB (twisted brain)\"\nstatus:\n  draft: 1\n  revision: 0\n  publish: 0\n  published: 0\n  rejected: 0\n  update: 0\ndescription: \"Test description\"\ntags: [\"test\", \"example\"]\n---\n\nThis is the article content.\n\n## Heading\n\nMore content here.\n`\n\n\tif err := os.WriteFile(testFile, []byte(content), 0644); err != nil {\n\t\tt.Fatalf(\"Failed to create test file: %v\", err)\n\t}\n\n\t// Parse article\n\tarticle, err := ParseArticle(testFile)\n\tif err != nil {\n\t\tt.Fatalf(\"ParseArticle failed: %v\", err)\n\t}\n\n\t// Validate fields\n\tif article.Title != \"Test Article\" {\n\t\tt.Errorf(\"Expected title 'Test Article', got '%s'\", article.Title)\n\t}\n\n\tif article.Author != \"TB (twisted brain)\" {\n\t\tt.Errorf(\"Expected author 'TB (twisted brain)', got '%s'\", article.Author)\n\t}\n\n\tif article.Description != \"Test description\" {\n\t\tt.Errorf(\"Expected description 'Test description', got '%s'\", article.Description)\n\t}\n\n\tif len(article.Tags) != 2 {\n\t\tt.Errorf(\"Expected 2 tags, got %d\", len(article.Tags))\n\t}\n\n\tif article.Status.Draft != 1 {\n\t\tt.Errorf(\"Expected draft status 1, got %d\", article.Status.Draft)\n\t}\n}","imports":["os","path/filepath","testing"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.857846517Z"}
{"type":"function","name":"TestGetCurrentStatus","file":"src/common/frontmatter_test.go","line":67,"endLine":109,"hash":"6e6be99166157daf","params":[{"name":"t","type":"*testing.T"}],"body":"func TestGetCurrentStatus(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tstatus   Status\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"draft only\",\n\t\t\tstatus:   Status{Draft: 1},\n\t\t\texpected: \"draft\",\n\t\t},\n\t\t{\n\t\t\tname:     \"draft then publish\",\n\t\t\tstatus:   Status{Draft: 1, Publish: 1},\n\t\t\texpected: \"publish\",\n\t\t},\n\t\t{\n\t\t\tname:     \"full workflow to published\",\n\t\t\tstatus:   Status{Draft: 1, Revision: 1, Publish: 1, Published: 1},\n\t\t\texpected: \"published\",\n\t\t},\n\t\t{\n\t\t\tname:     \"update after published\",\n\t\t\tstatus:   Status{Draft: 1, Publish: 1, Published: 1, Update: 1},\n\t\t\texpected: \"update\",\n\t\t},\n\t\t{\n\t\t\tname:     \"rejected\",\n\t\t\tstatus:   Status{Draft: 1, Publish: 1, Rejected: 1},\n\t\t\texpected: \"rejected\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tarticle := \u0026Article{Status: tt.status}\n\t\t\tresult := article.GetCurrentStatus()\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected status '%s', got '%s'\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","imports":["os","path/filepath","testing"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.857871856Z"}
{"type":"function","name":"TestUpdateStatus","file":"src/common/frontmatter_test.go","line":111,"endLine":133,"hash":"bc47b332dcabe538","params":[{"name":"t","type":"*testing.T"}],"body":"func TestUpdateStatus(t *testing.T) {\n\tarticle := \u0026Article{\n\t\tStatus: Status{Draft: 1},\n\t}\n\n\t// Update to publish (clears all other flags - Bug 8 fix)\n\tif err := article.UpdateStatus(\"publish\"); err != nil {\n\t\tt.Fatalf(\"UpdateStatus failed: %v\", err)\n\t}\n\n\t// Bug 8 fix: Only one status should be active at a time\n\tif article.Status.Draft != 0 {\n\t\tt.Error(\"Draft status should be cleared when setting new status\")\n\t}\n\n\tif article.Status.Publish != 1 {\n\t\tt.Error(\"Publish status should be set\")\n\t}\n\n\tif article.GetCurrentStatus() != \"publish\" {\n\t\tt.Errorf(\"Current status should be 'publish', got '%s'\", article.GetCurrentStatus())\n\t}\n}","imports":["os","path/filepath","testing"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.857892514Z"}
{"type":"function","name":"TestUpdateStatusClearsOtherFlags","file":"src/common/frontmatter_test.go","line":136,"endLine":188,"hash":"dc134c0f98aa82f8","params":[{"name":"t","type":"*testing.T"}],"body":"func TestUpdateStatusClearsOtherFlags(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tstartStatus Status\n\t\tnewStatus   string\n\t\twantStatus  Status\n\t}{\n\t\t{\n\t\t\tname:        \"draft to publish clears draft\",\n\t\t\tstartStatus: Status{Draft: 1},\n\t\t\tnewStatus:   \"publish\",\n\t\t\twantStatus:  Status{Publish: 1},\n\t\t},\n\t\t{\n\t\t\tname:        \"multiple flags to rejected clears all\",\n\t\t\tstartStatus: Status{Draft: 1, Revision: 1, Publish: 1},\n\t\t\tnewStatus:   \"rejected\",\n\t\t\twantStatus:  Status{Rejected: 1},\n\t\t},\n\t\t{\n\t\t\tname:        \"published to update clears published\",\n\t\t\tstartStatus: Status{Published: 1},\n\t\t\tnewStatus:   \"update\",\n\t\t\twantStatus:  Status{Update: 1},\n\t\t},\n\t\t{\n\t\t\tname:        \"all flags set to draft clears all\",\n\t\t\tstartStatus: Status{Draft: 1, Revision: 1, Publish: 1, Published: 1, Rejected: 1, Update: 1},\n\t\t\tnewStatus:   \"draft\",\n\t\t\twantStatus:  Status{Draft: 1},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tarticle := \u0026Article{Status: tt.startStatus}\n\n\t\t\tif err := article.UpdateStatus(tt.newStatus); err != nil {\n\t\t\t\tt.Fatalf(\"UpdateStatus failed: %v\", err)\n\t\t\t}\n\n\t\t\t// Verify only the expected flag is set\n\t\t\tif article.Status != tt.wantStatus {\n\t\t\t\tt.Errorf(\"Expected status %+v, got %+v\", tt.wantStatus, article.Status)\n\t\t\t}\n\n\t\t\t// Verify GetCurrentStatus returns expected value\n\t\t\tif article.GetCurrentStatus() != tt.newStatus {\n\t\t\t\tt.Errorf(\"Expected current status '%s', got '%s'\", tt.newStatus, article.GetCurrentStatus())\n\t\t\t}\n\t\t})\n\t}\n}","docstring":"TestUpdateStatusClearsOtherFlags tests that UpdateStatus ensures only one flag is active (Bug 8 fix)\n","imports":["os","path/filepath","testing"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.857908872Z"}
{"type":"function","name":"TestImageProcessor_Placeholder","file":"src/common/image-processor_test.go","line":9,"endLine":12,"hash":"2d85042a9bc84a49","params":[{"name":"t","type":"*testing.T"}],"body":"func TestImageProcessor_Placeholder(t *testing.T) {\n\t// Placeholder test to ensure test file structure is correct\n\tt.Skip(\"Image processor not yet implemented\")\n}","imports":["testing"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.860545826Z"}
{"type":"type","name":"FolderAliases","file":"src/config/config.go","line":11,"endLine":11,"hash":"53915167577b7181","body":"type FolderAliases map[string]map[string]string","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.865238416Z"}
{"type":"struct","name":"Config","file":"src/config/config.go","line":14,"endLine":27,"hash":"68b14d1bedfbd0ba","fields":["Dropbox","OpenRouter","Email","Approval","Ntfy","Hugo","Git","Rsync","Images","Deploy","Languages","Aliases"],"body":"type Config struct {\n\tDropbox       DropboxConfig    `yaml:\"dropbox\"`\n\tOpenRouter    OpenRouterConfig `yaml:\"openrouter\"`\n\tEmail         EmailConfig      `yaml:\"email\"`\n\tApproval      ApprovalConfig   `yaml:\"approval\"`\n\tNtfy          NtfyConfig       `yaml:\"ntfy\"`\n\tHugo          HugoConfig       `yaml:\"hugo\"`\n\tGit           GitConfig        `yaml:\"git\"`\n\tRsync         RsyncConfig      `yaml:\"rsync\"`\n\tImages        ImagesConfig     `yaml:\"images\"`\n\tDeploy        DeployConfig     `yaml:\"deploy\"`\n\tLanguages     []string         `yaml:\"languages\"`\n\tAliases       FolderAliases    `yaml:\"-\"` // Loaded separately\n}","docstring":"Config represents the application configuration\n","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.865251291Z"}
{"type":"struct","name":"DropboxConfig","file":"src/config/config.go","line":29,"endLine":32,"hash":"d240f4348f2e476d","fields":["BasePath","FolderLanguage"],"body":"type DropboxConfig struct {\n\tBasePath       string `yaml:\"base_path\"`\n\tFolderLanguage string `yaml:\"folder_language\"`\n}","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.865278042Z"}
{"type":"struct","name":"OpenRouterConfig","file":"src/config/config.go","line":34,"endLine":38,"hash":"60293eb781a74334","fields":["APIKey","Model","Endpoint"],"body":"type OpenRouterConfig struct {\n\tAPIKey   string `yaml:\"api_key\"`\n\tModel    string `yaml:\"model\"`\n\tEndpoint string `yaml:\"endpoint\"`\n}","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.865293464Z"}
{"type":"struct","name":"EmailConfig","file":"src/config/config.go","line":40,"endLine":53,"hash":"e93fdd8fab97b114","fields":["SMTPHost","SMTPPort","SMTPUser","SMTPPassword","FromAddress","ApprovalRecipient","IMAPHost","IMAPPort","IMAPUser","IMAPPassword"],"body":"type EmailConfig struct {\n\tSMTPHost          string `yaml:\"smtp_host\"`\n\tSMTPPort          int    `yaml:\"smtp_port\"`\n\tSMTPUser          string `yaml:\"smtp_user\"`\n\tSMTPPassword      string `yaml:\"smtp_password\"`\n\tFromAddress       string `yaml:\"from_address\"`\n\tApprovalRecipient string `yaml:\"approval_recipient\"`\n\n\t// IMAP for reading replies\n\tIMAPHost string `yaml:\"imap_host\"`\n\tIMAPPort int    `yaml:\"imap_port\"`\n\tIMAPUser string `yaml:\"imap_user\"`\n\tIMAPPassword string `yaml:\"imap_password\"`\n}","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.865298488Z"}
{"type":"struct","name":"ApprovalConfig","file":"src/config/config.go","line":55,"endLine":59,"hash":"9a164a7580ebcb0e","fields":["Host","Port","TailscaleHostname"],"body":"type ApprovalConfig struct {\n\tHost             string `yaml:\"host\"`\n\tPort             int    `yaml:\"port\"`\n\tTailscaleHostname string `yaml:\"tailscale_hostname\"`\n}","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.865308725Z"}
{"type":"struct","name":"NtfyConfig","file":"src/config/config.go","line":61,"endLine":65,"hash":"0b8c0aafa8f8b7da","fields":["Enabled","Server","Topic"],"body":"type NtfyConfig struct {\n\tEnabled bool   `yaml:\"enabled\"`\n\tServer  string `yaml:\"server\"`\n\tTopic   string `yaml:\"topic\"`\n}","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.865312841Z"}
{"type":"struct","name":"HugoConfig","file":"src/config/config.go","line":67,"endLine":71,"hash":"5c496b583fc853ff","fields":["SiteDir","PublicDir","MirrorDir"],"body":"type HugoConfig struct {\n\tSiteDir   string `yaml:\"site_dir\"`\n\tPublicDir string `yaml:\"public_dir\"`\n\tMirrorDir string `yaml:\"mirror_dir\"`\n}","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.865316875Z"}
{"type":"struct","name":"ImagesConfig","file":"src/config/config.go","line":73,"endLine":80,"hash":"f17dec41e088a3a5","fields":["MinWidth","MinHeight","Formats","Sizes","Quality","Icons"],"body":"type ImagesConfig struct {\n\tMinWidth int               `yaml:\"min_width\"`\n\tMinHeight int              `yaml:\"min_height\"`\n\tFormats  []string          `yaml:\"formats\"`\n\tSizes    map[string][2]int `yaml:\"sizes\"`\n\tQuality  map[string]int    `yaml:\"quality\"`\n\tIcons    IconsConfig       `yaml:\"icons\"`\n}","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.865325736Z"}
{"type":"struct","name":"IconsConfig","file":"src/config/config.go","line":82,"endLine":86,"hash":"79f00a1a3c209766","fields":["FaviconSizes","AppleTouchIconSizes","AndroidIconSizes"],"body":"type IconsConfig struct {\n\tFaviconSizes         []int `yaml:\"favicon_sizes\"`\n\tAppleTouchIconSizes  []int `yaml:\"apple_touch_icon_sizes\"`\n\tAndroidIconSizes     []int `yaml:\"android_icon_sizes\"`\n}","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.865336739Z"}
{"type":"struct","name":"DeployConfig","file":"src/config/config.go","line":88,"endLine":92,"hash":"446fdcee871df7ac","fields":["Method","RsyncTarget","RsyncOpts"],"body":"type DeployConfig struct {\n\tMethod      string `yaml:\"method\"`\n\tRsyncTarget string `yaml:\"rsync_target\"`\n\tRsyncOpts   string `yaml:\"rsync_opts\"`\n}","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.865340769Z"}
{"type":"struct","name":"GitConfig","file":"src/config/config.go","line":94,"endLine":97,"hash":"70a6d991f8cf4fea","fields":["MirrorRepo","AutoCommit"],"body":"type GitConfig struct {\n\tMirrorRepo string `yaml:\"mirror_repo\"`\n\tAutoCommit bool   `yaml:\"auto_commit\"`\n}","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.865346969Z"}
{"type":"struct","name":"RsyncConfig","file":"src/config/config.go","line":99,"endLine":105,"hash":"230df939819f8699","fields":["Enabled","Host","User","TargetPath","SSHKey"],"body":"type RsyncConfig struct {\n\tEnabled    bool   `yaml:\"enabled\"`\n\tHost       string `yaml:\"host\"`\n\tUser       string `yaml:\"user\"`\n\tTargetPath string `yaml:\"target_path\"`\n\tSSHKey     string `yaml:\"ssh_key\"`\n}","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.865350946Z"}
{"type":"function","name":"Load","file":"src/config/config.go","line":108,"endLine":158,"hash":"8728799649039b79","params":[{"name":"path","type":"string"},{"name":"aliasesPath","type":"string"}],"returns":"(*Config, error)","body":"func Load(path string, aliasesPath string) (*Config, error) {\n\t// Load .env file from project root\n\tenvPath := \"/home/ubuntu/hugo-norsetinge/.env\"\n\tif err := godotenv.Load(envPath); err != nil {\n\t\t// .env is optional, don't fail if it doesn't exist\n\t\tif !os.IsNotExist(err) {\n\t\t\treturn nil, fmt.Errorf(\"error loading .env file: %w\", err)\n\t\t}\n\t}\n\n\tdata, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read config file: %w\", err)\n\t}\n\n\tvar cfg Config\n\tif err := yaml.Unmarshal(data, \u0026cfg); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse config: %w\", err)\n\t}\n\n\t// Load folder aliases\n\taliasesData, err := os.ReadFile(aliasesPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read folder aliases file: %w\", err)\n\t}\n\n\tif err := yaml.Unmarshal(aliasesData, \u0026cfg.Aliases); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse folder aliases: %w\", err)\n\t}\n\n\t// Override secrets from environment variables\n\tif apiKey := os.Getenv(\"OPENROUTER_API_KEY\"); apiKey != \"\" {\n\t\tcfg.OpenRouter.APIKey = apiKey\n\t}\n\tif smtpPass := os.Getenv(\"SMTP_PASSWORD\"); smtpPass != \"\" {\n\t\tcfg.Email.SMTPPassword = smtpPass\n\t}\n\tif imapPass := os.Getenv(\"IMAP_PASSWORD\"); imapPass != \"\" {\n\t\tcfg.Email.IMAPPassword = imapPass\n\t}\n\tif ntfyTopic := os.Getenv(\"NTFY_TOPIC\"); ntfyTopic != \"\" {\n\t\tcfg.Ntfy.Topic = ntfyTopic\n\t}\n\n\t// Validate required fields\n\tif err := cfg.Validate(); err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid config: %w\", err)\n\t}\n\n\treturn \u0026cfg, nil\n}","docstring":"Load reads and parses the configuration file\n","imports":["fmt","os","github.com/joho/godotenv","gopkg.in/yaml.v3"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.865363412Z"}
{"type":"function","name":"Config.Validate","file":"src/config/config.go","line":161,"endLine":173,"hash":"37f318cda6fae3d5","returns":"error","body":"func (c *Config) Validate() error {\n\tif c.Dropbox.BasePath == \"\" {\n\t\treturn fmt.Errorf(\"dropbox.base_path is required\")\n\t}\n\tif c.Dropbox.FolderLanguage == \"\" {\n\t\treturn fmt.Errorf(\"dropbox.folder_language is required\")\n\t}\n\tif c.Hugo.SiteDir == \"\" {\n\t\treturn fmt.Errorf(\"hugo.site_dir is required\")\n\t}\n\t// Add more validation as needed\n\treturn nil\n}","docstring":"Validate checks if required configuration fields are set\n","imports":["fmt","os","github.com/joho/godotenv","gopkg.in/yaml.v3"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.865379458Z"}
{"type":"function","name":"TestLoadConfig","file":"src/config/config_test.go","line":9,"endLine":93,"hash":"540369a46e825641","params":[{"name":"t","type":"*testing.T"}],"body":"func TestLoadConfig(t *testing.T) {\n\t// Create temp config file\n\ttmpDir := t.TempDir()\n\tconfigFile := filepath.Join(tmpDir, \"config.yaml\")\n\n\tconfigContent := `\ndropbox:\n  base_path: \"Dropbox/Publisering/NorseTinge\"\n  folder_language: \"da\"\n\nopenrouter:\n  api_key: \"test-key\"\n  model: \"anthropic/claude-3.5-sonnet\"\n  endpoint: \"https://openrouter.ai/api/v1\"\n\nemail:\n  smtp_host: \"smtp.example.com\"\n  smtp_port: 587\n  smtp_user: \"user@example.com\"\n  smtp_password: \"password\"\n  from_address: \"norsetinge@example.com\"\n  approval_recipient: \"editor@example.com\"\n\napproval:\n  host: \"0.0.0.0\"\n  port: 8080\n  tailscale_hostname: \"norsetinge.tailnet.ts.net\"\n\nhugo:\n  site_dir: \"site\"\n  public_dir: \"site/public\"\n\nimages:\n  min_width: 1200\n  min_height: 630\n  formats: [\"webp\", \"jpeg\", \"png\"]\n  quality:\n    webp: 85\n    jpeg: 90\n    png: 95\n\ndeploy:\n  method: \"rsync\"\n  rsync_target: \"user@host.com:/var/www/\"\n  rsync_opts: \"-avz --delete\"\n\nlanguages:\n  - en\n  - da\n  - sv\n`\n\n\tif err := os.WriteFile(configFile, []byte(configContent), 0644); err != nil {\n\t\tt.Fatalf(\"Failed to create test config: %v\", err)\n\t}\n\n\t// Load config\n\tcfg, err := Load(configFile)\n\tif err != nil {\n\t\tt.Fatalf(\"Load failed: %v\", err)\n\t}\n\n\t// Validate fields\n\tif cfg.Dropbox.BasePath != \"Dropbox/Publisering/NorseTinge\" {\n\t\tt.Errorf(\"Expected base_path 'Dropbox/Publisering/NorseTinge', got '%s'\", cfg.Dropbox.BasePath)\n\t}\n\n\tif cfg.Dropbox.FolderLanguage != \"da\" {\n\t\tt.Errorf(\"Expected folder_language 'da', got '%s'\", cfg.Dropbox.FolderLanguage)\n\t}\n\n\t// Note: OpenRouter.APIKey may be overridden by OPENROUTER_API_KEY env var\n\t// If env var is set, it will override the config file value\n\tif cfg.OpenRouter.APIKey == \"\" {\n\t\tt.Error(\"Expected api_key to be set (from config or env)\")\n\t}\n\n\tif cfg.Approval.Port != 8080 {\n\t\tt.Errorf(\"Expected approval port 8080, got %d\", cfg.Approval.Port)\n\t}\n\n\tif len(cfg.Languages) != 3 {\n\t\tt.Errorf(\"Expected 3 languages, got %d\", len(cfg.Languages))\n\t}\n}","imports":["os","path/filepath","testing"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.865891192Z"}
{"type":"function","name":"TestValidateConfig","file":"src/config/config_test.go","line":95,"endLine":148,"hash":"7816657b0f0a0381","params":[{"name":"t","type":"*testing.T"}],"body":"func TestValidateConfig(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tconfig  Config\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid config\",\n\t\t\tconfig: Config{\n\t\t\t\tDropbox: DropboxConfig{\n\t\t\t\t\tBasePath:       \"test/path\",\n\t\t\t\t\tFolderLanguage: \"en\",\n\t\t\t\t},\n\t\t\t\tHugo: HugoConfig{\n\t\t\t\t\tSiteDir: \"site\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"missing base_path\",\n\t\t\tconfig: Config{\n\t\t\t\tDropbox: DropboxConfig{\n\t\t\t\t\tFolderLanguage: \"en\",\n\t\t\t\t},\n\t\t\t\tHugo: HugoConfig{\n\t\t\t\t\tSiteDir: \"site\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"missing folder_language\",\n\t\t\tconfig: Config{\n\t\t\t\tDropbox: DropboxConfig{\n\t\t\t\t\tBasePath: \"test/path\",\n\t\t\t\t},\n\t\t\t\tHugo: HugoConfig{\n\t\t\t\t\tSiteDir: \"site\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\terr := tt.config.Validate()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Validate() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}","imports":["os","path/filepath","testing"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.86590893Z"}
{"type":"struct","name":"Deployer","file":"src/deployer/deployer.go","line":15,"endLine":17,"hash":"46790bb5ed032a99","fields":["cfg"],"body":"type Deployer struct {\n\tcfg *config.Config\n}","docstring":"Deployer handles deployment pipeline\n","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.867344611Z"}
{"type":"function","name":"NewDeployer","file":"src/deployer/deployer.go","line":20,"endLine":22,"hash":"9de023f67f65ea04","params":[{"name":"cfg","type":"*config.Config"}],"returns":"*Deployer","body":"func NewDeployer(cfg *config.Config) *Deployer {\n\treturn \u0026Deployer{cfg: cfg}\n}","docstring":"NewDeployer creates a new deployer\n","imports":["fmt","log","os","os/exec","path/filepath","time","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.867356024Z"}
{"type":"function","name":"Deployer.Deploy","file":"src/deployer/deployer.go","line":25,"endLine":49,"hash":"36b3c14417f63647","params":[{"name":"publicDir","type":"string"},{"name":"mirrorDir","type":"string"}],"returns":"error","body":"func (d *Deployer) Deploy(publicDir, mirrorDir string) error {\n\tlog.Printf(\"üöÄ Starting deployment pipeline...\")\n\n\t// 1. Sync public to mirror\n\tif err := d.syncToMirror(publicDir, mirrorDir); err != nil {\n\t\treturn fmt.Errorf(\"failed to sync to mirror: %w\", err)\n\t}\n\n\t// 2. Git commit and push mirror\n\tif d.cfg.Git.AutoCommit {\n\t\tif err := d.gitCommitAndPush(mirrorDir); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to git commit/push: %w\", err)\n\t\t}\n\t}\n\n\t// 3. Rsync to webhost\n\tif d.cfg.Rsync.Enabled {\n\t\tif err := d.rsyncToWebhost(mirrorDir); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to rsync to webhost: %w\", err)\n\t\t}\n\t}\n\n\tlog.Printf(\"‚úÖ Deployment complete!\")\n\treturn nil\n}","docstring":"Deploy runs the complete deployment pipeline\n","imports":["fmt","log","os","os/exec","path/filepath","time","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.867363798Z"}
{"type":"function","name":"Deployer.syncToMirror","file":"src/deployer/deployer.go","line":52,"endLine":81,"hash":"669077bd0f8715da","params":[{"name":"publicDir","type":"string"},{"name":"mirrorDir","type":"string"}],"returns":"error","body":"func (d *Deployer) syncToMirror(publicDir, mirrorDir string) error {\n\tlog.Printf(\"üìã Syncing public ‚Üí mirror...\")\n\n\t// Ensure the mirror directory exists\n\tif err := os.MkdirAll(mirrorDir, 0755); err != nil {\n\t\treturn fmt.Errorf(\"failed to create mirror directory: %w\", err)\n\t}\n\n\t// Use rsync to efficiently sync the directories\n\t// -a: archive mode (preserves permissions, etc.)\n\t// --delete: removes files from mirror that are not in public\n\t// --exclude: keeps the .git directory in the mirror\n\targs := []string{\n\t\t\"-a\",\n\t\t\"--delete\",\n\t\t\"--exclude\", \".git\",\n\t\tpublicDir + \"/\", // Trailing slash is important!\n\t\tmirrorDir + \"/\",\n\t}\n\n\tcmd := exec.Command(\"rsync\", args...)\n\toutput, err := cmd.CombinedOutput()\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"rsync to mirror failed: %w\\nOutput: %s\", err, string(output))\n\t}\n\n\tlog.Printf(\"‚úì Synced to mirror: %s\", mirrorDir)\n\treturn nil\n}","docstring":"syncToMirror copies public directory to mirror using rsync for efficiency.\n","imports":["fmt","log","os","os/exec","path/filepath","time","norsetinge/src/config"],"language":"go","indexedAt":"2025-10-03T16:18:26.86737589Z"}
{"type":"function","name":"Deployer.gitCommitAndPush","file":"src/deployer/deployer.go","line":84,"endLine":127,"hash":"d5180a0227cb82d9","params":[{"name":"mirrorDir","type":"string"}],"returns":"error","body":"func (d *Deployer) gitCommitAndPush(mirrorDir string) error {\n\tlog.Printf(\"üì¶ Committing and pushing to git...\")\n\n\t// Initialize git repo if not exists\n\tgitDir := filepath.Join(mirrorDir, \".git\")\n\tif _, err := os.Stat(gitDir); os.IsNotExist(err) {\n\t\tif err := d.gitInit(mirrorDir); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Git add all\n\tcmd := exec.Command(\"git\", \"add\", \".\")\n\tcmd.Dir = mirrorDir\n\tif output, err := cmd.CombinedOutput(); err != nil {\n\t\treturn fmt.Errorf(\"git add failed: %s\", string(output))\n\t}\n\n\t// Check if there are changes to commit\n\tcmd = exec.Command(\"git\", \"diff\", \"--cached\", \"--quiet\")\n\tcmd.Dir = mirrorDir\n\tif err := cmd.Run(); err == nil {\n\t\tlog.Printf(\"‚ÑπÔ∏è  No changes to commit\")\n\t\treturn nil\n\t}\n\n\t// Git commit with timestamp\n\tcommitMsg := fmt.Sprintf(\"Deploy: %s\", time.Now().Format(\"2006-01-02 15:04:05\"))\n\tcmd = exec.Command(\"git\", \"commit\", \"-m\", commitMsg)\n\tcmd.Dir = mirrorDir\n\tif output, err := cmd.CombinedOutput(); err != nil {\n\t\treturn fmt.Errorf(\"git commit failed: %s\", string(output))\n\t}\n\n\t// Git push\n\tcmd = exec.Command(\"git\", \"push\")\n\tcmd.Dir = mirrorDir\n\tif output, err := cmd.CombinedOutput(); err != nil {\n\t\treturn fmt.Errorf(\"git push failed: %s\", string(output))\n\t}\n\n\tlog.Printf(\"‚úì Pushed to git: %s\", d.cfg.Git.MirrorRepo)\n\treturn nil\n}","docstring":"gitCommitAndPush commits and pushes mirror to private repo\n","imports":["fmt","log","os","os/exec","path/filepath","time","norsetinge/src/config"],"language":"go","indexedAt":"2025-10-03T16:18:26.867392857Z"}
{"type":"function","name":"Deployer.gitInit","file":"src/deployer/deployer.go","line":130,"endLine":156,"hash":"62a74f409ad5b524","params":[{"name":"mirrorDir","type":"string"}],"returns":"error","body":"func (d *Deployer) gitInit(mirrorDir string) error {\n\tlog.Printf(\"Initializing git repository...\")\n\n\t// Git init\n\tcmd := exec.Command(\"git\", \"init\")\n\tcmd.Dir = mirrorDir\n\tif output, err := cmd.CombinedOutput(); err != nil {\n\t\treturn fmt.Errorf(\"git init failed: %s\", string(output))\n\t}\n\n\t// Set remote\n\tcmd = exec.Command(\"git\", \"remote\", \"add\", \"origin\", d.cfg.Git.MirrorRepo)\n\tcmd.Dir = mirrorDir\n\tif output, err := cmd.CombinedOutput(); err != nil {\n\t\treturn fmt.Errorf(\"git remote add failed: %s\", string(output))\n\t}\n\n\t// Set default branch to main\n\tcmd = exec.Command(\"git\", \"branch\", \"-M\", \"main\")\n\tcmd.Dir = mirrorDir\n\tif output, err := cmd.CombinedOutput(); err != nil {\n\t\treturn fmt.Errorf(\"git branch failed: %s\", string(output))\n\t}\n\n\tlog.Printf(\"‚úì Git repository initialized\")\n\treturn nil\n}","docstring":"gitInit initializes git repo and sets remote\n","imports":["fmt","log","os","os/exec","path/filepath","time","norsetinge/src/config"],"language":"go","indexedAt":"2025-10-03T16:18:26.867407863Z"}
{"type":"function","name":"Deployer.rsyncToWebhost","file":"src/deployer/deployer.go","line":159,"endLine":187,"hash":"e503b125a0018a5f","params":[{"name":"mirrorDir","type":"string"}],"returns":"error","body":"func (d *Deployer) rsyncToWebhost(mirrorDir string) error {\n\tlog.Printf(\"üåê Deploying to webhost via rsync...\")\n\n\t// Build rsync command with --delete flag\n\ttarget := fmt.Sprintf(\"%s@%s:%s\", d.cfg.Rsync.User, d.cfg.Rsync.Host, d.cfg.Rsync.TargetPath)\n\n\targs := []string{\n\t\t\"-avz\",\n\t\t\"--delete\", // Remove files on remote that don't exist in source\n\t\t\"--exclude\", \".git\",\n\t}\n\n\t// Add SSH key if specified\n\tif d.cfg.Rsync.SSHKey != \"\" {\n\t\targs = append(args, \"-e\", fmt.Sprintf(\"ssh -i %s\", d.cfg.Rsync.SSHKey))\n\t}\n\n\t// Add source and target\n\targs = append(args, mirrorDir+\"/\", target)\n\n\tcmd := exec.Command(\"rsync\", args...)\n\toutput, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"rsync failed: %s\", string(output))\n\t}\n\n\tlog.Printf(\"‚úì Deployed to: %s\", target)\n\treturn nil\n}","docstring":"rsyncToWebhost syncs mirror to webhost using rsync\n","imports":["fmt","log","os","os/exec","path/filepath","time","norsetinge/src/config"],"language":"go","indexedAt":"2025-10-03T16:18:26.867418832Z"}
{"type":"function","name":"main","file":"src/main.go","line":19,"endLine":112,"hash":"863dc072d0cab57c","body":"func main() {\n\tfmt.Println(\"Norsetinge - Automated Multilingual News Service\")\n\tfmt.Println(\"================================================\")\n\n\t// Define command-line flags for config paths\n\tconfigPath := flag.String(\"config\", \"/home/ubuntu/hugo-norsetinge/config.yaml\", \"Path to the config.yaml file\")\n\taliasesPath := flag.String(\"aliases\", \"/home/ubuntu/hugo-norsetinge/folder-aliases.yaml\", \"Path to the folder-aliases.yaml file\")\n\tflag.Parse()\n\n\t// Load config (use absolute path)\n\tcfg, err := config.Load(*configPath, *aliasesPath)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to load config: %v\", err)\n\t}\n\n\tlog.Printf(\"Loaded config: monitoring %s\", cfg.Dropbox.BasePath)\n\n\t// Create approval server\n\tapprovalServer := approval.NewServer(cfg)\n\n\t// Start approval server in background\n\tgo func() {\n\t\tlog.Printf(\"Starting approval server on port %d\", cfg.Approval.Port)\n\t\tif err := approvalServer.Start(); err != nil {\n\t\t\tlog.Fatalf(\"Approval server failed: %v\", err)\n\t\t}\n\t}()\n\n\t// Create watcher\n\tw, err := watcher.NewWatcher(cfg)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create watcher: %v\", err)\n\t}\n\n\t// Connect approval server to watcher\n\tw.SetApprovalServer(approvalServer)\n\n\t// Connect mover to approval server so it can move files\n\tapprovalServer.SetMover(w.GetMover())\n\n\t// Start watching\n\tif err := w.Start(); err != nil {\n\t\tlog.Fatalf(\"Failed to start watcher: %v\", err)\n\t}\n\n\tlog.Println(\"Watcher started. Monitoring for article changes...\")\n\n\t// Email notifications disabled - using ntfy only\n\n\t// Start periodic build+deploy (every 10 minutes)\n\tgo func() {\n\t\tticker := time.NewTicker(10 * time.Minute)\n\t\tdefer ticker.Stop()\n\n\t\thugoBuilder := builder.NewHugoBuilder(cfg)\n\t\tdep := deployer.NewDeployer(cfg)\n\n\t\tfor range ticker.C {\n\t\t\tlog.Printf(\"‚è∞ Running periodic build+deploy...\")\n\n\t\t\t// Build full site\n\t\t\tpublicDir, mirrorDir, err := hugoBuilder.BuildFullSite()\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Error in periodic build: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Deploy\n\t\t\tif err := dep.Deploy(publicDir, mirrorDir); err != nil {\n\t\t\t\tlog.Printf(\"Error in periodic deploy: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tlog.Printf(\"‚úÖ Periodic build+deploy completed\")\n\t\t}\n\t}()\n\n\tlog.Println(\"Press Ctrl+C to stop\")\n\n\t// Listen for events\n\tgo func() {\n\t\tfor event := range w.Events() {\n\t\t\tlog.Printf(\"üìÑ Event: %v - %s\", event.Type, event.FilePath)\n\t\t}\n\t}()\n\n\t// Wait for interrupt signal\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n\t\u003c-sigChan\n\n\tlog.Println(\"Shutting down...\")\n\tw.Stop()\n}","imports":["flag","fmt","log","os","os/signal","syscall","time","norsetinge/src/approval","norsetinge/src/builder","norsetinge/src/config","norsetinge/src/deployer","norsetinge/src/watcher"],"language":"go","indexedAt":"2025-10-03T16:18:26.867711842Z"}
{"type":"struct","name":"Mover","file":"src/watcher/mover.go","line":15,"endLine":18,"hash":"b7ea92f099cab37c","fields":["cfg","aliases"],"body":"type Mover struct {\n\tcfg     *config.Config\n\taliases config.FolderAliases\n}","docstring":"Mover handles moving files between folders based on status\n","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.868030503Z"}
{"type":"function","name":"NewMover","file":"src/watcher/mover.go","line":21,"endLine":26,"hash":"0495583f4d5135c9","params":[{"name":"cfg","type":"*config.Config"}],"returns":"(*Mover, error)","body":"func NewMover(cfg *config.Config) (*Mover, error) {\n\treturn \u0026Mover{\n\t\tcfg:     cfg,\n\t\taliases: cfg.Aliases,\n\t}, nil\n}","docstring":"NewMover creates a new file mover\n","imports":["fmt","os","path/filepath","norsetinge/src/common","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.868045008Z"}
{"type":"function","name":"Mover.GetFolderForStatus","file":"src/watcher/mover.go","line":29,"endLine":38,"hash":"188ad0db1492fd93","params":[{"name":"status","type":"string"}],"returns":"(string, error)","body":"func (m *Mover) GetFolderForStatus(status string) (string, error) {\n\tlang := m.cfg.Dropbox.FolderLanguage\n\n\tfolderName, ok := m.aliases[lang][status]\n\tif !ok {\n\t\treturn \"\", fmt.Errorf(\"no folder mapping for status '%s' in language '%s'\", status, lang)\n\t}\n\n\treturn filepath.Join(m.cfg.Dropbox.BasePath, folderName), nil\n}","docstring":"GetFolderForStatus returns the folder path for a given status\n","imports":["fmt","os","path/filepath","norsetinge/src/common","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.868053786Z"}
{"type":"function","name":"Mover.MoveArticle","file":"src/watcher/mover.go","line":41,"endLine":72,"hash":"ab6ba355f4c74990","params":[{"name":"article","type":"*common.Article"}],"returns":"error","body":"func (m *Mover) MoveArticle(article *common.Article) error {\n\tcurrentStatus := article.GetCurrentStatus()\n\n\ttargetFolder, err := m.GetFolderForStatus(currentStatus)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get target folder: %w\", err)\n\t}\n\n\t// Ensure target folder exists\n\tif err := os.MkdirAll(targetFolder, 0755); err != nil {\n\t\treturn fmt.Errorf(\"failed to create target folder: %w\", err)\n\t}\n\n\t// Get filename\n\tfilename := filepath.Base(article.FilePath)\n\ttargetPath := filepath.Join(targetFolder, filename)\n\n\t// Check if source and target are the same\n\tif article.FilePath == targetPath {\n\t\treturn nil // Already in correct location\n\t}\n\n\t// Move file\n\tif err := os.Rename(article.FilePath, targetPath); err != nil {\n\t\treturn fmt.Errorf(\"failed to move file: %w\", err)\n\t}\n\n\t// Update article filepath\n\tarticle.FilePath = targetPath\n\n\treturn nil\n}","docstring":"MoveArticle moves an article to the appropriate folder based on its status\n","imports":["fmt","os","path/filepath","norsetinge/src/common","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.86806893Z"}
{"type":"function","name":"Mover.ProcessArticleStatusChange","file":"src/watcher/mover.go","line":75,"endLine":94,"hash":"664f03d731c8bede","params":[{"name":"filePath","type":"string"}],"returns":"error","body":"func (m *Mover) ProcessArticleStatusChange(filePath string) error {\n\t// Parse article\n\tarticle, err := common.ParseArticle(filePath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to parse article: %w\", err)\n\t}\n\n\t// Ignore articles with no status set (status: unknown)\n\tcurrentStatus := article.GetCurrentStatus()\n\tif currentStatus == \"unknown\" {\n\t\treturn nil // No status flags set - ignore this article\n\t}\n\n\t// Move to appropriate folder\n\tif err := m.MoveArticle(article); err != nil {\n\t\treturn fmt.Errorf(\"failed to move article: %w\", err)\n\t}\n\n\treturn nil\n}","docstring":"ProcessArticleStatusChange handles status changes and moves files accordingly\n","imports":["fmt","os","path/filepath","norsetinge/src/common","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.86808222Z"}
{"type":"function","name":"Mover.GetAllMonitoredFolders","file":"src/watcher/mover.go","line":97,"endLine":110,"hash":"190f5bba8ce7a703","returns":"([]string, error)","body":"func (m *Mover) GetAllMonitoredFolders() ([]string, error) {\n\tstatuses := []string{\"draft\", \"revision\", \"publish\", \"published\", \"rejected\", \"update\"}\n\tfolders := make([]string, 0, len(statuses))\n\n\tfor _, status := range statuses {\n\t\tfolder, err := m.GetFolderForStatus(status)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfolders = append(folders, folder)\n\t}\n\n\treturn folders, nil\n}","docstring":"GetAllMonitoredFolders returns all folders that should be monitored\n","imports":["fmt","os","path/filepath","norsetinge/src/common","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.86809364Z"}
{"type":"function","name":"TestMoveArticle","file":"src/watcher/mover_test.go","line":12,"endLine":94,"hash":"0790d6b98a10f1c7","params":[{"name":"t","type":"*testing.T"}],"body":"func TestMoveArticle(t *testing.T) {\n\t// Create temp directory structure\n\ttmpDir := t.TempDir()\n\tbasePath := filepath.Join(tmpDir, \"NorseTinge\")\n\n\t// Create folders\n\tfolders := []string{\"kladde\", \"udgiv\", \"udgivet\", \"afvist\", \"afventer-rettelser\", \"opdater\"}\n\tfor _, folder := range folders {\n\t\tif err := os.MkdirAll(filepath.Join(basePath, folder), 0755); err != nil {\n\t\t\tt.Fatalf(\"Failed to create folder: %v\", err)\n\t\t}\n\t}\n\n\t// Create test article in kladde\n\ttestFile := filepath.Join(basePath, \"kladde\", \"test.md\")\n\tarticleContent := `---\ntitle: \"Test Article\"\nauthor: \"TB\"\nstatus:\n  draft: 1\n  revision: 0\n  publish: 0\n  published: 0\n  rejected: 0\n  update: 0\n---\n\nTest content\n`\n\tif err := os.WriteFile(testFile, []byte(articleContent), 0644); err != nil {\n\t\tt.Fatalf(\"Failed to create test file: %v\", err)\n\t}\n\n\t// Setup mover\n\tcfg := \u0026config.Config{\n\t\tDropbox: config.DropboxConfig{\n\t\t\tBasePath:       basePath,\n\t\t\tFolderLanguage: \"da\",\n\t\t},\n\t}\n\n\tmover, err := NewMover(cfg, \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create mover: %v\", err)\n\t}\n\n\t// Test: Article should stay in kladde (status is draft)\n\tarticle, _ := common.ParseArticle(testFile)\n\tif err := mover.MoveArticle(article); err != nil {\n\t\tt.Errorf(\"MoveArticle failed: %v\", err)\n\t}\n\n\tif article.FilePath != testFile {\n\t\tt.Errorf(\"File should not move, expected %s, got %s\", testFile, article.FilePath)\n\t}\n\n\t// Change status to publish\n\tarticle.UpdateStatus(\"publish\")\n\tif err := article.WriteFrontmatter(); err != nil {\n\t\tt.Fatalf(\"Failed to write frontmatter: %v\", err)\n\t}\n\n\t// Re-parse and move\n\tarticle, _ = common.ParseArticle(article.FilePath)\n\tif err := mover.MoveArticle(article); err != nil {\n\t\tt.Errorf(\"MoveArticle failed: %v\", err)\n\t}\n\n\texpectedPath := filepath.Join(basePath, \"udgiv\", \"test.md\")\n\tif article.FilePath != expectedPath {\n\t\tt.Errorf(\"Expected file at %s, got %s\", expectedPath, article.FilePath)\n\t}\n\n\t// Verify file exists at new location\n\tif _, err := os.Stat(expectedPath); os.IsNotExist(err) {\n\t\tt.Error(\"File does not exist at target location\")\n\t}\n\n\t// Verify file no longer exists at old location\n\tif _, err := os.Stat(testFile); !os.IsNotExist(err) {\n\t\tt.Error(\"File still exists at old location\")\n\t}\n}","imports":["os","path/filepath","testing","norsetinge/src/common","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.868549668Z"}
{"type":"function","name":"TestGetFolderForStatus","file":"src/watcher/mover_test.go","line":96,"endLine":131,"hash":"42132a4d1e36dbd7","params":[{"name":"t","type":"*testing.T"}],"body":"func TestGetFolderForStatus(t *testing.T) {\n\tcfg := \u0026config.Config{\n\t\tDropbox: config.DropboxConfig{\n\t\t\tBasePath:       \"/test/base\",\n\t\t\tFolderLanguage: \"da\",\n\t\t},\n\t}\n\n\tmover, err := NewMover(cfg, \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create mover: %v\", err)\n\t}\n\n\ttests := []struct {\n\t\tstatus   string\n\t\texpected string\n\t}{\n\t\t{\"draft\", \"/test/base/kladde\"},\n\t\t{\"publish\", \"/test/base/udgiv\"},\n\t\t{\"published\", \"/test/base/udgivet\"},\n\t\t{\"rejected\", \"/test/base/afvist\"},\n\t\t{\"revision\", \"/test/base/afventer-rettelser\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.status, func(t *testing.T) {\n\t\t\tfolder, err := mover.GetFolderForStatus(tt.status)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"GetFolderForStatus failed: %v\", err)\n\t\t\t}\n\t\t\tif folder != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %s, got %s\", tt.expected, folder)\n\t\t\t}\n\t\t})\n\t}\n}","imports":["os","path/filepath","testing","norsetinge/src/common","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.868586366Z"}
{"type":"function","name":"TestGetAllMonitoredFolders","file":"src/watcher/mover_test.go","line":133,"endLine":154,"hash":"69b8a1f6d2528e11","params":[{"name":"t","type":"*testing.T"}],"body":"func TestGetAllMonitoredFolders(t *testing.T) {\n\tcfg := \u0026config.Config{\n\t\tDropbox: config.DropboxConfig{\n\t\t\tBasePath:       \"/test\",\n\t\t\tFolderLanguage: \"da\",\n\t\t},\n\t}\n\n\tmover, err := NewMover(cfg, \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create mover: %v\", err)\n\t}\n\n\tfolders, err := mover.GetAllMonitoredFolders()\n\tif err != nil {\n\t\tt.Fatalf(\"GetAllMonitoredFolders failed: %v\", err)\n\t}\n\n\tif len(folders) != 6 {\n\t\tt.Errorf(\"Expected 6 folders, got %d\", len(folders))\n\t}\n}","imports":["os","path/filepath","testing","norsetinge/src/common","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.868608201Z"}
{"type":"struct","name":"Watcher","file":"src/watcher/watcher.go","line":16,"endLine":22,"hash":"55c55b1b3a5e19d0","fields":["cfg","mover","watcher","events","approvalServer"],"body":"type Watcher struct {\n\tcfg            *config.Config\n\tmover          *Mover\n\twatcher        *fsnotify.Watcher\n\tevents         chan Event\n\tapprovalServer ApprovalServer\n}","docstring":"Watcher monitors Dropbox folders for file changes\n","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.869341738Z"}
{"type":"interface","name":"ApprovalServer","file":"src/watcher/watcher.go","line":25,"endLine":27,"hash":"85f5aabb7a398baf","methods":["RequestApproval"],"body":"type ApprovalServer interface {\n\tRequestApproval(article *common.Article) error\n}","docstring":"ApprovalServer interface for triggering approval\n","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.869353645Z"}
{"type":"struct","name":"Event","file":"src/watcher/watcher.go","line":30,"endLine":33,"hash":"03304d82f9ee2959","fields":["Type","FilePath"],"body":"type Event struct {\n\tType     EventType\n\tFilePath string\n}","docstring":"Event represents a file system event\n","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.869365698Z"}
{"type":"type","name":"EventType","file":"src/watcher/watcher.go","line":36,"endLine":36,"hash":"cd6cef3985daef03","body":"type EventType int","docstring":"EventType represents the type of file event\n","exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.869373084Z"}
{"type":"function","name":"NewWatcher","file":"src/watcher/watcher.go","line":45,"endLine":62,"hash":"fa6b626d6b4ed363","params":[{"name":"cfg","type":"*config.Config"}],"returns":"(*Watcher, error)","body":"func NewWatcher(cfg *config.Config) (*Watcher, error) {\n\tmover, err := NewMover(cfg)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create mover: %w\", err)\n\t}\n\n\tfsWatcher, err := fsnotify.NewWatcher()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create fsnotify watcher: %w\", err)\n\t}\n\n\treturn \u0026Watcher{\n\t\tcfg:     cfg,\n\t\tmover:   mover,\n\t\twatcher: fsWatcher,\n\t\tevents:  make(chan Event, 100),\n\t}, nil\n}","docstring":"NewWatcher creates a new file watcher\n","imports":["fmt","log","os","path/filepath","time","github.com/fsnotify/fsnotify","norsetinge/src/common","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.869386235Z"}
{"type":"function","name":"Watcher.SetApprovalServer","file":"src/watcher/watcher.go","line":65,"endLine":67,"hash":"86ba307d07442cc0","params":[{"name":"server","type":"ApprovalServer"}],"body":"func (w *Watcher) SetApprovalServer(server ApprovalServer) {\n\tw.approvalServer = server\n}","docstring":"SetApprovalServer sets the approval server for handling approvals\n","imports":["fmt","log","os","path/filepath","time","github.com/fsnotify/fsnotify","norsetinge/src/common","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.869406866Z"}
{"type":"function","name":"Watcher.GetMover","file":"src/watcher/watcher.go","line":70,"endLine":72,"hash":"4f4186f1dc401149","returns":"*Mover","body":"func (w *Watcher) GetMover() *Mover {\n\treturn w.mover\n}","docstring":"GetMover returns the mover for file operations\n","imports":["fmt","log","os","path/filepath","time","github.com/fsnotify/fsnotify","norsetinge/src/common","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.869415063Z"}
{"type":"function","name":"Watcher.Start","file":"src/watcher/watcher.go","line":75,"endLine":99,"hash":"4a5b2fc62266f63f","returns":"error","body":"func (w *Watcher) Start() error {\n\tfolders, err := w.mover.GetAllMonitoredFolders()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get monitored folders: %w\", err)\n\t}\n\n\t// Add all folders to watcher\n\tfor _, folder := range folders {\n\t\tif err := w.watcher.Add(folder); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to watch folder %s: %w\", folder, err)\n\t\t}\n\t\tlog.Printf(\"Watching folder: %s\", folder)\n\t}\n\n\t// Start event processing goroutine\n\tgo w.processEvents()\n\n\t// Start periodic folder scanner to enforce status-based file organization\n\tgo w.periodicFolderScan()\n\n\t// Run initial scan immediately\n\tgo w.scanAllFolders()\n\n\treturn nil\n}","docstring":"Start begins monitoring all configured folders\n","imports":["fmt","log","os","path/filepath","time","github.com/fsnotify/fsnotify","norsetinge/src/common","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.869424331Z"}
{"type":"function","name":"Watcher.processEvents","file":"src/watcher/watcher.go","line":102,"endLine":140,"hash":"3ebd08fca83aa36c","body":"func (w *Watcher) processEvents() {\n\t// Debounce timer to avoid processing rapid successive events\n\tdebounce := make(map[string]*time.Timer)\n\n\tfor {\n\t\tselect {\n\t\tcase event, ok := \u003c-w.watcher.Events:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Only process .md files\n\t\t\tif filepath.Ext(event.Name) != \".md\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Skip temp files\n\t\t\tif filepath.Base(event.Name)[0] == '.' {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Debounce: wait 500ms before processing\n\t\t\tif timer, exists := debounce[event.Name]; exists {\n\t\t\t\ttimer.Stop()\n\t\t\t}\n\n\t\t\tdebounce[event.Name] = time.AfterFunc(500*time.Millisecond, func() {\n\t\t\t\tw.handleEvent(event)\n\t\t\t\tdelete(debounce, event.Name)\n\t\t\t})\n\n\t\tcase err, ok := \u003c-w.watcher.Errors:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlog.Printf(\"Watcher error: %v\", err)\n\t\t}\n\t}\n}","docstring":"processEvents handles fsnotify events and converts them to our event type\n","imports":["fmt","log","os","path/filepath","time","github.com/fsnotify/fsnotify","norsetinge/src/common","norsetinge/src/config"],"language":"go","indexedAt":"2025-10-03T16:18:26.869444295Z"}
{"type":"function","name":"Watcher.handleEvent","file":"src/watcher/watcher.go","line":143,"endLine":211,"hash":"697211d5f6363d9d","params":[{"name":"event","type":"fsnotify.Event"}],"body":"func (w *Watcher) handleEvent(event fsnotify.Event) {\n\tvar eventType EventType\n\n\tswitch {\n\tcase event.Op\u0026fsnotify.Create == fsnotify.Create:\n\t\teventType = EventCreated\n\t\tlog.Printf(\"File created: %s\", event.Name)\n\tcase event.Op\u0026fsnotify.Write == fsnotify.Write:\n\t\teventType = EventModified\n\t\tlog.Printf(\"File modified: %s\", event.Name)\n\tcase event.Op\u0026fsnotify.Remove == fsnotify.Remove:\n\t\teventType = EventDeleted\n\t\tlog.Printf(\"File deleted: %s\", event.Name)\n\tdefault:\n\t\treturn // Ignore other events\n\t}\n\n\t// Send event to channel\n\tw.events \u003c- Event{\n\t\tType:     eventType,\n\t\tFilePath: event.Name,\n\t}\n\n\t// Process status changes (move files if needed)\n\tif eventType == EventCreated || eventType == EventModified {\n\t\tif err := w.mover.ProcessArticleStatusChange(event.Name); err != nil {\n\t\t\tlog.Printf(\"Failed to process article status change: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Check if article is now in publish folder (udgiv)\n\t\tarticle, err := common.ParseArticle(event.Name)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to parse article: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Trigger approval for publish status OR update flag\n\t\tcurrentStatus := article.GetCurrentStatus()\n\t\tif (currentStatus == \"publish\" || currentStatus == \"update\") \u0026\u0026 w.approvalServer != nil {\n\t\t\tlog.Printf(\"Triggering approval for: %s (status: %s)\", article.Title, currentStatus)\n\t\t\tif err := w.approvalServer.RequestApproval(article); err != nil {\n\t\t\t\tlog.Printf(\"Failed to request approval: %v\", err)\n\t\t\t}\n\t\t} else if currentStatus == \"rejected\" \u0026\u0026 article.Status.Update == 1 \u0026\u0026 w.approvalServer != nil {\n\t\t\t// Article in rejected folder with update flag - send for re-approval\n\t\t\tlog.Printf(\"Update requested for rejected article: %s\", article.Title)\n\n\t\t\t// Change status to publish and move to publish folder\n\t\t\tarticle.UpdateStatus(\"publish\")\n\t\t\tarticle.Status.Update = 0 // Clear update flag\n\t\t\tif err := article.WriteFrontmatter(); err != nil {\n\t\t\t\tlog.Printf(\"Failed to update article status: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Move to publish folder\n\t\t\tif err := w.mover.MoveArticle(article); err != nil {\n\t\t\t\tlog.Printf(\"Failed to move article to publish folder: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tlog.Printf(\"Triggering re-approval for: %s\", article.Title)\n\t\t\tif err := w.approvalServer.RequestApproval(article); err != nil {\n\t\t\t\tlog.Printf(\"Failed to request approval: %v\", err)\n\t\t\t}\n\t\t}\n\t}\n}","docstring":"handleEvent processes a single file event\n","imports":["fmt","log","os","path/filepath","time","github.com/fsnotify/fsnotify","norsetinge/src/common","norsetinge/src/config"],"language":"go","indexedAt":"2025-10-03T16:18:26.869472454Z"}
{"type":"function","name":"Watcher.Events","file":"src/watcher/watcher.go","line":214,"endLine":216,"hash":"9d9c95dba17b6884","returns":"unknown","body":"func (w *Watcher) Events() \u003c-chan Event {\n\treturn w.events\n}","docstring":"Events returns the event channel\n","imports":["fmt","log","os","path/filepath","time","github.com/fsnotify/fsnotify","norsetinge/src/common","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.869505693Z"}
{"type":"function","name":"Watcher.Stop","file":"src/watcher/watcher.go","line":219,"endLine":222,"hash":"6ce07703e00feab1","returns":"error","body":"func (w *Watcher) Stop() error {\n\tclose(w.events)\n\treturn w.watcher.Close()\n}","docstring":"Stop stops the watcher\n","imports":["fmt","log","os","path/filepath","time","github.com/fsnotify/fsnotify","norsetinge/src/common","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.869519284Z"}
{"type":"function","name":"Watcher.periodicFolderScan","file":"src/watcher/watcher.go","line":226,"endLine":233,"hash":"0c82572ed34a51d2","body":"func (w *Watcher) periodicFolderScan() {\n\tticker := time.NewTicker(2 * time.Minute) // Scan every 2 minutes\n\tdefer ticker.Stop()\n\n\tfor range ticker.C {\n\t\tw.scanAllFolders()\n\t}\n}","docstring":"periodicFolderScan runs a periodic scan of all folders to enforce status-based organization\nThis ensures files are in the correct folder based on their status flags, regardless of file events\n","imports":["fmt","log","os","path/filepath","time","github.com/fsnotify/fsnotify","norsetinge/src/common","norsetinge/src/config"],"language":"go","indexedAt":"2025-10-03T16:18:26.869530968Z"}
{"type":"function","name":"Watcher.scanAllFolders","file":"src/watcher/watcher.go","line":236,"endLine":252,"hash":"b197815c7e8652ed","body":"func (w *Watcher) scanAllFolders() {\n\tfolders, err := w.mover.GetAllMonitoredFolders()\n\tif err != nil {\n\t\tlog.Printf(\"Failed to get monitored folders for scan: %v\", err)\n\t\treturn\n\t}\n\n\tlog.Printf(\"üîç Starting folder scan to enforce status-based organization...\")\n\n\tfor _, folder := range folders {\n\t\tif err := w.scanFolder(folder); err != nil {\n\t\t\tlog.Printf(\"Failed to scan folder %s: %v\", folder, err)\n\t\t}\n\t}\n\n\tlog.Printf(\"‚úÖ Folder scan complete\")\n}","docstring":"scanAllFolders scans all monitored folders and enforces status-based file organization\n","imports":["fmt","log","os","path/filepath","time","github.com/fsnotify/fsnotify","norsetinge/src/common","norsetinge/src/config"],"language":"go","indexedAt":"2025-10-03T16:18:26.869541068Z"}
{"type":"function","name":"Watcher.scanFolder","file":"src/watcher/watcher.go","line":255,"endLine":279,"hash":"f237570239570d09","params":[{"name":"folder","type":"string"}],"returns":"error","body":"func (w *Watcher) scanFolder(folder string) error {\n\tentries, err := os.ReadDir(folder)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read directory: %w\", err)\n\t}\n\n\tfor _, entry := range entries {\n\t\t// Skip directories and non-.md files\n\t\tif entry.IsDir() || filepath.Ext(entry.Name()) != \".md\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Skip hidden files\n\t\tif entry.Name()[0] == '.' {\n\t\t\tcontinue\n\t\t}\n\n\t\tfilePath := filepath.Join(folder, entry.Name())\n\t\tif err := w.processArticleFile(filePath); err != nil {\n\t\t\tlog.Printf(\"Failed to process %s: %v\", filePath, err)\n\t\t}\n\t}\n\n\treturn nil\n}","docstring":"scanFolder scans a single folder and processes all .md files\n","imports":["fmt","log","os","path/filepath","time","github.com/fsnotify/fsnotify","norsetinge/src/common","norsetinge/src/config"],"language":"go","indexedAt":"2025-10-03T16:18:26.869555961Z"}
{"type":"function","name":"Watcher.processArticleFile","file":"src/watcher/watcher.go","line":282,"endLine":318,"hash":"81c51b073cc48065","params":[{"name":"filePath","type":"string"}],"returns":"error","body":"func (w *Watcher) processArticleFile(filePath string) error {\n\t// Parse the article\n\tarticle, err := common.ParseArticle(filePath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to parse article: %w\", err)\n\t}\n\n\t// Process status changes (will move file if needed)\n\tif err := w.mover.ProcessArticleStatusChange(filePath); err != nil {\n\t\treturn fmt.Errorf(\"failed to process status change: %w\", err)\n\t}\n\n\t// Re-parse to get updated file path after potential move\n\tarticle, err = common.ParseArticle(article.FilePath)\n\tif err != nil {\n\t\t// File may have been moved, try original path\n\t\tarticle, err = common.ParseArticle(filePath)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to re-parse article: %w\", err)\n\t\t}\n\t}\n\n\t// Check if article needs approval (publish or update status)\n\tcurrentStatus := article.GetCurrentStatus()\n\tif (currentStatus == \"publish\" || currentStatus == \"update\") \u0026\u0026 w.approvalServer != nil {\n\t\t// Check if already pending approval\n\t\t// We don't want to spam approval requests for articles already in the queue\n\t\tlog.Printf(\"üìã Article ready for approval: %s (status: %s, ID: %s)\", article.Title, currentStatus, article.ID)\n\n\t\t// Trigger approval\n\t\tif err := w.approvalServer.RequestApproval(article); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to request approval: %w\", err)\n\t\t}\n\t}\n\n\treturn nil\n}","docstring":"processArticleFile processes a single article file and ensures it's in the correct folder\n","imports":["fmt","log","os","path/filepath","time","github.com/fsnotify/fsnotify","norsetinge/src/common","norsetinge/src/config"],"language":"go","indexedAt":"2025-10-03T16:18:26.869575584Z"}
{"type":"function","name":"TestWatcher","file":"src/watcher/watcher_test.go","line":12,"endLine":118,"hash":"e965ed88d3bd9ac2","params":[{"name":"t","type":"*testing.T"}],"body":"func TestWatcher(t *testing.T) {\n\t// Create temp directory structure\n\ttmpDir := t.TempDir()\n\tbasePath := filepath.Join(tmpDir, \"NorseTinge\")\n\n\t// Create all required folders\n\tfolders := []string{\"kladde\", \"udgiv\", \"udgivet\", \"afvist\", \"afventer-rettelser\", \"opdater\"}\n\tfor _, folder := range folders {\n\t\tif err := os.MkdirAll(filepath.Join(basePath, folder), 0755); err != nil {\n\t\t\tt.Fatalf(\"Failed to create folder: %v\", err)\n\t\t}\n\t}\n\n\t// Setup config\n\tcfg := \u0026config.Config{\n\t\tDropbox: config.DropboxConfig{\n\t\t\tBasePath:       basePath,\n\t\t\tFolderLanguage: \"da\",\n\t\t},\n\t}\n\n\t// Create watcher\n\tw, err := NewWatcher(cfg, \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create watcher: %v\", err)\n\t}\n\tdefer w.Stop()\n\n\t// Start watching\n\tif err := w.Start(); err != nil {\n\t\tt.Fatalf(\"Failed to start watcher: %v\", err)\n\t}\n\n\t// Create test file\n\ttestFile := filepath.Join(basePath, \"kladde\", \"test.md\")\n\tarticleContent := `---\ntitle: \"Test Article\"\nauthor: \"TB\"\nstatus:\n  draft: 1\n  revision: 0\n  publish: 0\n  published: 0\n  rejected: 0\n  update: 0\n---\n\nTest content\n`\n\n\t// Write file and wait for event\n\tif err := os.WriteFile(testFile, []byte(articleContent), 0644); err != nil {\n\t\tt.Fatalf(\"Failed to create test file: %v\", err)\n\t}\n\n\t// Wait for event (could be Create or Write depending on OS)\n\tselect {\n\tcase event := \u003c-w.Events():\n\t\tif event.Type != EventCreated \u0026\u0026 event.Type != EventModified {\n\t\t\tt.Errorf(\"Expected EventCreated or EventModified, got %v\", event.Type)\n\t\t}\n\t\tif event.FilePath != testFile {\n\t\t\tt.Errorf(\"Expected filepath %s, got %s\", testFile, event.FilePath)\n\t\t}\n\tcase \u003c-time.After(2 * time.Second):\n\t\tt.Error(\"Timeout waiting for event\")\n\t}\n\n\t// Modify file\n\tmodifiedContent := `---\ntitle: \"Test Article\"\nauthor: \"TB\"\nstatus:\n  draft: 1\n  revision: 0\n  publish: 1\n  published: 0\n  rejected: 0\n  update: 0\n---\n\nModified content\n`\n\n\tif err := os.WriteFile(testFile, []byte(modifiedContent), 0644); err != nil {\n\t\tt.Fatalf(\"Failed to modify test file: %v\", err)\n\t}\n\n\t// Wait for modify event\n\tselect {\n\tcase event := \u003c-w.Events():\n\t\tif event.Type != EventModified {\n\t\t\tt.Errorf(\"Expected EventModified, got %v\", event.Type)\n\t\t}\n\tcase \u003c-time.After(2 * time.Second):\n\t\tt.Error(\"Timeout waiting for modify event\")\n\t}\n\n\t// Give the mover time to move the file\n\ttime.Sleep(1 * time.Second)\n\n\t// Verify file was moved to udgiv folder\n\texpectedPath := filepath.Join(basePath, \"udgiv\", \"test.md\")\n\tif _, err := os.Stat(expectedPath); os.IsNotExist(err) {\n\t\tt.Error(\"File was not moved to udgiv folder\")\n\t}\n}","imports":["os","path/filepath","testing","time","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.87010614Z"}
{"type":"function","name":"TestWatcherIgnoresNonMarkdownFiles","file":"src/watcher/watcher_test.go","line":120,"endLine":162,"hash":"b6d608ca583808f3","params":[{"name":"t","type":"*testing.T"}],"body":"func TestWatcherIgnoresNonMarkdownFiles(t *testing.T) {\n\ttmpDir := t.TempDir()\n\tbasePath := filepath.Join(tmpDir, \"NorseTinge\")\n\n\t// Create all required folders\n\tfolders := []string{\"kladde\", \"udgiv\", \"udgivet\", \"afvist\", \"afventer-rettelser\", \"opdater\"}\n\tfor _, folder := range folders {\n\t\tif err := os.MkdirAll(filepath.Join(basePath, folder), 0755); err != nil {\n\t\t\tt.Fatalf(\"Failed to create folder: %v\", err)\n\t\t}\n\t}\n\n\tcfg := \u0026config.Config{\n\t\tDropbox: config.DropboxConfig{\n\t\t\tBasePath:       basePath,\n\t\t\tFolderLanguage: \"da\",\n\t\t},\n\t}\n\n\tw, err := NewWatcher(cfg, \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create watcher: %v\", err)\n\t}\n\tdefer w.Stop()\n\n\tif err := w.Start(); err != nil {\n\t\tt.Fatalf(\"Failed to start watcher: %v\", err)\n\t}\n\n\t// Create non-markdown file\n\ttestFile := filepath.Join(basePath, \"kladde\", \"test.txt\")\n\tif err := os.WriteFile(testFile, []byte(\"test\"), 0644); err != nil {\n\t\tt.Fatalf(\"Failed to create test file: %v\", err)\n\t}\n\n\t// Should NOT receive event\n\tselect {\n\tcase event := \u003c-w.Events():\n\t\tt.Errorf(\"Should not receive event for non-markdown file, got: %v\", event)\n\tcase \u003c-time.After(1 * time.Second):\n\t\t// Expected - no event received\n\t}\n}","imports":["os","path/filepath","testing","time","norsetinge/src/config"],"exports":true,"language":"go","indexedAt":"2025-10-03T16:18:26.870140952Z"}
